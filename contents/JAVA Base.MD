# [基础]-关键字

### 1. final关键字

- 修饰范围：

  > 类:表示类不可被继承  
  > 方法:表示方法不可被子类覆盖，但是可以重载  
  > 变量:表示变量一旦被赋值就不可以更改它的值。  
  >
  > > - 成员变量  
  > >   如果final修饰的是**类变量**，只能在**静态初始化块**中指定初始值或者**声明该类变量时**指定初始值。  
  > >   如果final修饰的是**成员变量**，可以在**非静态初始化块**声明该变量或者**构造器**中执行初始值。  
  > > - 局部变量  
  > >   系统**不会为局部变量进行初始化**，局部变量必须由程序员显示初始化。  
  > >   因此使用final修饰局部变量时，即可以在定义时指定默认值，也可以不指定默认值，而在后面的代码中对final变量赋初值(仅一次)  

### 2. static关键字



# [基础]-概念

### 1. 接口 与 抽象类 区别

- 抽象类可以**存在普通成员函数**，而接口中**只能存在public abstract方法**。

- 抽象类中的**成员变量**可以是**各种类型**的，而接口中的成员变量**只能是public static final类型**的。

- 抽象类只能**继承一个**，接口可以**实现多个**。

  - 目的

    > - 接口的设计**目的，是对类的行为进行约束**  
    >   (更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为)，  
    >   也就是提供一种机制，可以强制要求不同的类具有相同的行为。  
    >   它只约束了行为的有无，但不对如何实现行为进行限制。
    > - 而抽象类的**设计目的，是代码复用**。  
    >   当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时(A的非真子集，记为B)，  
    >   可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。  
    >   而A减B的部分，留给各个子类自己实现。  
    >   正是因为A-B在这里没有实现，所以抽象类不允许实例化出来(否则当调用到A-B时，无法执行)。

  - 象类型不同

    > - 抽象类是对**类本质的抽象，表达的是is a的关系**。  
    >   比如:BMw is a car 。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。
    > - 而接口是对**行为的抽象，表达的是likea的关系**。  
    >   比如:Bird like a Aircraft(像飞行器一样可以飞)，但其本质上is a Bird。  
    >   接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。

  - 使用场景

    > - 当你关注一个事物的本质的时候，用抽象类。
    > - 当你关注一个操作的时候，用接口。

- 总结
  - **单继承多实现**
  - **抽象类**的功能要远超过接口，但是，**定义抽象类的代价高**。  
    因为高级语言来说(从实际设计上来说也是)每个类只能继承一个类。  
    在这个类中，你**必须继承或编写出其所有子类的所有共性**。  
  - 虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。  
    而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度

### 2. 深拷贝 和 浅拷贝 区别

深拷贝和浅拷贝就是指**对象的拷贝**，  
一个对象中存在两种类型的属性，一种是**基本数据类型**，一种是**实例对象的引用**。

> - 浅拷贝是指，只会拷贝**基本数据类型的值，以及实例对象的引用地址**，  
>   并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象
> - 深拷贝是指，既会拷贝**基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制**，  
>   深拷贝出来的对象，内部的类执行指向的不是同一个对象

### 3. 泛型 extends 和 super 区别
- `<? extends T>` 类T的任何子类  
- `<? super T>` 类T的任何父类

### 4. 重写 和 重载 区别

- 重载：

  同一个类中，方法名相同  
  参数类型不同，个数不同，顺序不同，方法返回值，访问修饰符不同  
  发生在编译时

- 重写：

  发生在子类中，方法名，参数列表，必须相同  
  返回值范围小于父类，抛出异常范围小于等于父类，访问修饰符范围大于等于父类  
  如果父类方法访问修饰符为private子类则不能重写  

### 5. JDK,JRE,JVM区别

- jdk（Java Development Kit），包含 JRE + java开发工具包
- jre（java runtime environment）,包含 bin (JVM) + lib
- jvm（Java Virtual Mechinal）, java虚拟机 

### 6. 泛型

- 定义：允许在编译时对类型进行参数化的特性。

- 优势：

  > **类型安全：** 通过在编译时进行类型检查，减少运行时错误。  
  > **代码重用：** 使得类和方法能够处理不同类型的数据，提高了代码的可重用性。   
  > **消除类型强制转换：** 减少显式的类型转换，代码更加清晰、易于理解。  
  > **泛型算法：** 使得算法可以独立于数据类型，增加了算法的通用性和灵活性。  
  > **与集合框架的集成：** Java的集合框架广泛使用泛型，提高了集合操作的类型安全和易用性。  

### 7. 反射及用途

- 定义：Java反射机制是指在运行状态中，获取类的所有属性和方法，或动态调用方法。

- 使用方式：

  > **1、获取Class对象的三种方式：** 对象.getClass()方法，Class.forName(String className)，Clazz.class属性。  
  > **2、创建对象：** newInstance()。  
  > **3、获取方法：** getDeclaredMethods()  
  > **4、访问字段：** getDeclaredFields()  
  > **5、调用方法：** Method.invoke()  

### 8. 自定义注解

```
public @interface Demo{
}
```

- @Target：修饰范围

  > **ElementType.class**
  >
  > - CONSTRUCTOR:用于描述构造器  
  >   FIELD:用于描述域  
  >   LOCAL_VARIABLE:用于描述局部变量  
  >   METHOD:用于描述方法  
  >   PACKAGE:用于描述包  
  >   PARAMETER:用于描述参数  
  >   TYPE:用于描述类、接口(包括注解类型) 或enum声明

- @Retention: 生命周期

  > **RetentionPoicy.class**
  >
  > - SOURCE：在源文件中有效（即源文件保留）  
  >   CLASS：在class文件中有效（即class保留）  
  >   RUNTIME：在运行时有效（即运行时保留）  

- @Documented

- @Inherited: 是否可用于继承

- **允许的数据类型**

  > - 基本类型（int,float,boolean,byte,double,char,long,short）
  > - String  
  > - Class
  > - enum
  > - Annotation
  > - 上述类型的数组

# 源码分析





# 异常体系

### 1.体系结构图

<img src="../pictures/java/java execption struct.png" alt="img" style="zoom:70%;" />

### 2. 分类

Error：程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。
Exception：不会导致程序停止

> - RunTimeException运行时异常：发生在程序运行过程中，会导致程序当前线程执行失败。
> - CheckedException检查异常：发生在程序编译过程中，会导致程序编译不通过



# 面试题

### 1. 基础类

#### 1. equals 与 “==”区别

> “==”对比栈中的值，对于基本类型是变量值，引用类型是堆中内存地址的值

#### 2.equals 与 hashcode关系

- hashcode

  > hashCode() 函数获取哈希码(散列码),是一个int整数。
  > 作用是确定该对象在哈希表中的索引位置。
  > 定义在JDK的Object中，Java中的任何类都包含有hashcode() 函数。
  > 散列表存储的是键值对(key-value)，根据“键”快速的检索出对应的"值”。这其中就利用到了散列码。

- 为什么要有hashcode

  > **Hashset如何检查重复**
  > 先计算对象的hashcode值 判断对象位置，
  > 有值，这时会调用equals()方法来检查两个对象是否真的相同。
  > 不同的话，就会重新散列到其他位置。
  > 这样就大大减少了equals的次数，相应就大大提高了执行速度。

- 总结

  - 如果两个对象相等，则hashcode一定也是相同的, 调用equals方法都返回true
  - 两个对象有相同的hashcode值，它们也不一定是相等的
  - 因此，**equals方法被覆盖过，则hashcode方法也必须被覆盖**
  - hashCode()的默认行为是对堆上的对象产生独特值。
    如果没有重写hashcode()，则该class的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)

`额外普及`

```
哈希表：就是通过一个映射函数f(key)将一组数据散列存储在数组中的一种数据结构。
哈希冲突：对于不同的关键字，可能得到同一个哈希地址
如何减少哈希冲突: 选取好的哈希函数。常用的构造哈希函数的方法：除留取余法、直接定址法、数字分析法等。
如何处理哈希冲突: 开放定址法、再哈希法、建立公共溢出区、链地址法
```

#### 3. 基本数据类型封装类缓存

- Byte类缓存范围：[-128,127] 共256个值。
- Short类缓存范围：[-128,127] 共256个值。
- Character类缓存范围：[0,127] 共128个值。
- Integer类默认缓存范围：[-128,127] 共256个值，可以通过修改VM参数-XX:AutoBoxCacheMax=200 即可修改缓存上限到200
- Long类缓存范围：[-128,127] 共256个值。
- Boolean类就缓存两个值：true、false。

#### 4. String,StringBuffer,StringBuilder区别

- string 不可变， StringBuffer StringBuilder 可变

- StringBuffer相比对StringBuilder是线程安全

#### 5. List 和 Set区别

- list： 有序，可重复，允许多个null元素对象，可使用iterator取所有元素， 或者get取元素
- set：无序，不可重复，最多允许一个null值， 只能用iterator遍历获取元素

#### 6. Arraylist 和 Linkedlist区别

- ArrayList：

  > 基于动态数据，连续内存存储，适合下标访问(随机访问)  
  > 扩容机制：
  >
  > - 默认数组长度是10， 扩容因子1.5，  
  > - 数组长度固定，超出数据要新建数组，然后做数据拷贝和回收，  
  > - 数据插入不是尾插法涉及到数据的移动
  > - 使用尾插法&指定初始容量极大提升性能，甚至超过linkedlist

- LinkedList：

  > 基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询  
  > 便利linkedlist必须使用iterator不能使用for，因为每次for循环体内通过get取得某一元素都需要对list重新进行遍历，性能消耗极大
  > 另外不要试图使用indexof等返回元素索引，会对链表进行遍历，当结果为空时会遍历整个列表

#### 7. CopyOnWriteArrayList的底层原理

- 原理

  > - 内部也是用过数组来实现。
  >   向CopyOnwriteArayList添加元素时，会**复制一个新的数组**，**写操作在新数组**上进行，**读操作在原数组**上进行
  >
  >   ```
  >   add() {
  >   	final ReentrantLock lock = this.lock;
  >   	lock.lock();
  >   	···
  >   }
  >   ```
  >
  > - **写操作会加锁**，防止出现并发写入丢失数据的问题
  > - 写操作结束之后会把**原数组指向新数组**

- 优缺点

  > 优点：允许在**写操作时读取数据，提高读性能**，适合读多写少场景
  > 缺点：占内存，**可能读到的数据不是实时最新**，不适合实时性要求很高的场最

#### 8. HashMap.put()方法

- 根据Key通过哈希算法与与运算得出数组下标

- 如果数组下标位置元素为空，则将key和value封装为Entny对象(JDK1.7中是Entry对象，JDK1.8中是Node对象)并放入该位置

- 如果数组下标位置元素不为空，则要分情况讨论

  > - JDK1.7
  >
  >   **先判断是否需要扩容**，如果要扩容就进行扩容，如果不用扩容就生成Entny对象，并使用**头插法**添加到当前位置的链表中
  >
  > - JDK1.8
  >
  >   > - 判断当前位置上的Node的类型
  >   > - 如果是**红黑树Node**，则将key和value封装为一个红黑树节点并添加到红黑树中去，
  >   >   在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value
  >   > - 如果是**Node对象是链表节点**，则将key和vaue封装为一个链表Node并通过尾插法插入到链表的最后位置去，  
  >   >   因为是**尾插法**，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，  
  >   >   如果存在则更新value, 当遍历完链表后，将新链表Node插入到链表中，  
  >   >   **插入到链表后**，会看当前链表的节点个数，如果超过了8，那么则会将该**链表转成红黑树**  
  >   > - 将key和value封装为Node插入到链表或红黑树中后，  
  >   >   再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束PUT方法  

#### 9. HashMap扩容机制原理

扩容因子：0.75
扩容触发阈值：容量 * 扩容因子

`1.7版本`

1.先生成新数组
2.遍历老数组中的每个位置上的链表上的每个元素
3.取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标
4.将元素添加到新数组中去
5.所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

`1.8版本`

1.先生成新数组
2.遍历老数组中的每个位置上的链表或红黑树
3.如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去
4.如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置
	a.统计每个下标位置的元素个数
	b.如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置
	c.如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置
5.所有元素转移完了之后，将新数组值给HashMap对象的table属性

#### 10. HashMap 和 HashTable区别和原理

`区别:`

(1)HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全
(2)HashMap允许key和value为null，而HashTable不允许

`底层实现:数组+链表实现`

jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在

- 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，

- 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组，

- 如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，

  链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表

- key为null，存在下标0的位置

#### 11. ConcurrentHashMap，jdk7、jdk8区别

`new ConcurrentHashMap(32, 0.75, 16)`	（容量32, 分段锁个数16，扩容因子0.75）

`jdk7：`
**数据结构:** ReentrantLock+Segment+HashEntry.，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构。

**元素查询: **二次hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。

**锁:** Segment分段锁 Segment继承了ReentrantLock，锁定操作的segment，其他的segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩客不会影响其他的segment。

get方法无需加锁，数组使用volatile保证可见性

**扩容机制：**
1.1.7版本的ConcurrentHashMap是基于Seqment分段实现的
2.每个Segment相对于一个小型的HashMap
3.每个Segment内部会进行扩容，和HashMap的扩容逻辑类似
4.先生成新的数组，然后转移元素到新数组中
5.扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值



`jdk8:`

**数据结构: **synchronized+CAS+Node+红黑树，Node的val和next都用volatile修饰，保证可见性。
查找，替换，赋值操作使用CAS。扩容，哈希冲突使用synchronized

**锁:** 锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作、并发扩容

**读操作无锁:**
Node的val和next使用volatile修饰，读写线程对该变量互相可见
数组用volatile修饰，保证扩容时被读线程感知

**扩容机制：**

1.1.8版本的ConcurrentHashMap不再基于Seqment实现
2.当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容
3.如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容
4.ConcurrentHashMap是支持多个线程同时扩容的
5.扩容之前也先生成一个新的数组
6.在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作

#### 12. 为什么局部内部类和匿名内部类只能访问局部final变量

> 内部类在外部类执行结束后，不一定会销毁，
> 当内部类访问了外部类的变量时，为了防止变量被销毁后找不到，则会拷贝一份变量到内部类，
> 为了防止内部类使用拷贝变量的值发生改变，则需要在变量定义时加final进行修饰

#### 13. 一致性哈希、普通哈希、哈希槽？如何解决哈希冲突？

- 区别

  一致性哈希：为了解决分布式系统中扩容或者缩容节点时造成大量数据迁移的问题

- 解决方式

  - **开放定址法**：我们在遇到哈希冲突时，去寻找一个新的空闲的哈希地址。
  - **再哈希法**
  - **链地址法**：将所有哈希地址相同的记录都链接在同一链表中。
  - **建立公共溢出区**：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中。
