# Mysql

### 1. 架构 
<image src="../pictures/mysql/mysql%20architecture.png" />

![](../pictures/mysql/mysql%20architecture.png")

### 2.引擎 
<image src="../pictures/mysql/mysql%20engines.png" />

#### 2.1 MyISAM  & InnoDB区别

> 引擎查询:  `show engines;`

|              | MyISAM                                               | InnoDB                                     |
| ------------ | ---------------------------------------------------- | ------------------------------------------ |
| 事务         | ×                                                    | √                                          |
| 锁           | 表锁                                                 | 行锁                                       |
| 读写         | 相互阻塞                                             | 事务隔离级别相关                           |
| 外键约束     | ×                                                    | √                                          |
| 索引         | `全文索引`  `非聚簇索引`                             | `V5.5以上全文索引` `聚簇索引` `非聚簇索引` |
| 存储类型     | `.frm: 表定义`    `.myd: 数据文件`  `.myi: 索引文件` | 索引和数据在同一个数据文件                 |
| 性能         | 读优写差                                             | 写优                                       |
| 是否存总行数 | √                                                    | ×                                          |
| B+ 树Data域  | 磁盘地址                                             | 行记录                                     |
| 崩溃修复     | ×                                                    | √                                          |
| 回表         | √                                                    | 区分情况                                   |
| 必须主键     | ×                                                    | √                                          |

### 3. 索引

#### 3.1 索引设计思想：

> 用空间换时间，减少磁盘IO次数

#### 3.2 Mysql 数据读取

> 按页读取， 每页16K

#### 3.3 [索引分类](https://blog.csdn.net/hzether/article/details/144859053)

> **分类维度：**
>
> 按数据结构分类：B+Tree、Hash、Full-Text、R-Tree  
> 按功能分类：主键索引、唯一索引、普通索引、全文索引、组合索引  
> 按存储方式分类：聚簇索引、非聚簇索引（辅助索引）  
> 按覆盖范围分类：覆盖索引、非覆盖索引  
> 按索引列数量分：单列索引、多列索引  



|          | B+Tree                       | Hash                     | Full-Text                                | R-Tree               | 主键                           | 唯一                                   | 普通               | 组合                                 |
| -------- | ---------------------------- | ------------------------ | ---------------------------------------- | -------------------- | ------------------------------ | -------------------------------------- | ------------------ | ------------------------------------ |
| 数据结构 | B+Tree                       | Hash                     | 倒排索引                                 | R-Tree               | B+Tree                         | B+Tree                                 | B+Tree             | B+Tree                               |
| 功能     | **普通索引、<br />主键索引** | 普通索引                 | 全文索引                                 | 空间索引             | **主键索引**                   | **唯一索引**                           | 普通索引           | **普通索引**                         |
| 存储方式 | **聚簇/非聚簇**              | 非聚簇                   | 非聚簇                                   | 非聚簇               | **聚簇**                       | **非聚簇/聚簇**                        | 非聚簇             | **非聚簇**                           |
| 覆盖范围 | 覆盖/非覆盖                  | 非覆盖                   | 非覆盖                                   | 非覆盖               | 覆盖/非覆盖                    | 覆盖/非覆盖                            | 覆盖/非覆盖        | 覆盖/非覆盖                          |
| 特点     |                              |                          | 1.用于全文搜索<br />2.支持自然语言查询。 |                      | **值唯一、非空**               | **值唯一、可空**                       | **无唯一约束**     | 1.多个列索引<br />2.遵循最左前缀原则 |
| 优点     |                              | 查询速度极快             | 支持复杂文本搜索                         | 支持空间数据高效查询 | 保证数据**唯一性，查询效率高** | 保证数据**唯一性，查询效率高**         |                    |                                      |
| 缺点     |                              | **不支持范围查询和排序** | 查询性能受数据量影响                     | 使用场景有限         | 只能有一个主键索引             | **插入和更新检查唯一性**，可能影响性能 | 需要额外的存储空间 |                                      |
| 适用场景 | **等值查询、范围查询、排序** | **等值查询**             | 文本字段全文搜索                         | 地理空间数据查询     | **主键列**                     | **需要唯一性约束的列**                 | 需要加速查询的列   | 多列查询条件                         |

#### 3.4 索引数据结构

|                                     | 特点                                                         | 缺点                                                         |
|-------------------------------------| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 哈希表                                 | 增删改查效率高                                               | 1. 无序<br />2. 不支持范围查询                               |
| 二叉树                                 |                                                              | 1. 可能退化成链表<br />2. 树的深度会影响新增和查询效率，磁盘IO高 |
| 二叉平衡树                               | 左右子树高度差<=1                                            | 1. 树的深度会影响新增和查询效率，磁盘IO高                    |
| 红黑树                                 |                                                              |                                                              |
| [B 树](../pictures/mysql/B%20Tree.png)       | 0. 每个叶子节点都是一个**页(Page) / 磁盘块**<br />1. 非叶子节点数据结构**<键值Key : Data域 : 指针>** | 1. mysql 按页(16K)读取，data域占用节点存储<br />2. 查询可能需要进行向上递归查找 |
| [B+ 树](../pictures/mysql/B%20Tree%20Plus.png) | 0. 每个叶子节点都是一个**页(Page) / 磁盘块**<br />1. 非叶子节点数据结构**<键值Key : 指针>**<br />2. 非叶子节点索引也会存在子节点中<br />3. 最底叶子节点数据结构**<关键字 : 行记录>**<br />4. 最底叶子节点是连起来的**有序双向链表**（高效范围查询） |                                                              |

3.5 索引覆盖：索引包含了（或覆盖了）满足查询语句中字段与条件的数据

3.6 索引下推

3.7 回表

3.8 聚簇索引 & 非聚簇索引(辅助索引)

|            | 特点                                                         | 优点                           | 缺点                               | 适用场景                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------ | ---------------------------------- | ------------------------------------------------------------ |
| 聚簇索引   | 1. 索引和数据存储在一起，表数据按索引顺序存储。<br />2. 每张表只能有一个聚簇索引。 <br />3. 主键索引默认是聚簇索引。 | 查询效率高，<br />减少磁盘 I/O | 插入和更新时<br />可能引起数据重排 | 1. 主键索引<br />2. 唯一索引<br />(`主键不存在` & <br />`唯一列值不为空`) |
| 非聚簇索引 | 1. 索引和数据分开存储，索引中存储指向数据的指针<br />2. 每张表可以有多个非聚簇索引 |                                |                                    |                                                              |



### 4. 锁

#### 4.1 类型

- 按粒度分：
  行锁：悲观锁
  表锁：悲观锁
  间隙锁：锁区间
- **共享锁：读锁，可读不可写**
  **排他锁：写锁，不能读写**
- 意向锁
- 乐观锁：
  悲观锁：
- 死锁：
    - 参照[4.2节](#trans_selects)查询死锁信息。

#### <a id="trans_selects">4.2 查询</a>

> 正在进行中的事务：`SELECT * FROM information_schema.INNODB_TRX;`  
> 正在锁的事务： `SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;`  
> 等待锁的事务：`SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;`  
> 是否锁表：`SHOW OPEN TABLES where In_use > 0;`  
> 查看最近死锁的日志：`show engine innodb status;`  

### 5. 事务

#### 5.0 基础概念

> **事务概念和作用**：用于保证数据的一致性，事务是在数据库管理系统中执行的一个逻辑操作单元，要么都成功，要么都失败  
> **版本链**：数据表的一行记录，所有的历史版本数据组成的链表  
> **trx_id** (InnoDB 隐藏字段): 事务id（transaction id： InnoDB事务更新时生成），**该编号是严格按照递增顺序产生的**  
> **roll_pointer** (InnoDB 隐藏字段)：指向上一事务版本指针（InnoDB事务更新时生成，insert时无版本记录）  
> [**Consistent Read view**（一致性视图）](https://www.jianshu.com/p/56ad7ffc1886)  
>
> > m_ids：生成ReadView时当前系统中活跃的所有事务的事务id列表  
> > min_trx_id：生成ReadView时，m_ids中最小值  
> > max_trx_id：生成ReadView时系统中应该分配给下一个事务的id值（m_ids最大 + 1）  
> > creator_trx_id：生成该ReadView的事务的事务id  

#### 5.1 原子性(Atomicity)

> 原理：通过[**Undo log**](#un-re-do-log)记录事务恢复SQL，保证原子性。  
> **记录**：buffer pool 数据页修改前，记录到undolog buffer  
> **删除**：事务提交后，通过后台purge线程进行回收  
> **写入**：在数据修改前写入   
> **应用**：[MVCC](#mvcc)。  
>
> - `快照读：`读行数据被其他事务锁定时，可以从undo log中分析出该行记录以前的数据版本，让用户能够读取到历史数据快照。  
> - `当前读：`使用间隙锁

#### 5.2 持久性(Durability)

> 原理：通过[**Redo log**](#un-re-do-log)记录事务执行过程中的修改情况，保证持久性。  
> **记录**：buffer pool 数据页变更结束后，相应修改记录到redolog buffer  
> **删除**：由后台purge线程进行回收  
> **写入**：事务提交时写入（也有可能[提交前写入](https://cloud.tencent.com/developer/article/1945809)）  

#### 5.3 隔离性(Isolation)

> **RC && RR 隔离级别实现**: [MVCC机制](#mvcc)

| 隔离级别                       | 脏读 | 不可重复读 | 幻读                        |                                       |
| ------------------------------ | ---- | ---------- | --------------------------- | ------------------------------------- |
| 读未提交(RU, Read uncommitted) | √    | √          | √                           |                                       |
| 读已提交(RC, Read committed）  | ×    | √          | √`(通过mvcc)`               | 每个select<br />创建新Read View       |
| 可重复读(RR, Repeatable read） | ×    | ×          | √ `(通过mvcc & 间隙锁解决)` | 只在启动事务时<br />生成一个Read View |
| 串行化（Serializable）         | ×    | ×          | × `(读数据行加读写锁)`      |                                       |

#### 5.4 一致性(Consistency)

#### 5.5 <a id ="mvcc">MVCC（多版本并发控制）</a>

>原理：
>
>> 通过**Read View**和**Undo Log版本链元素中两个隐藏列（trx_id 和 roll_pointer）**比对，  
>> 如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，  
>> 从而控制并发事务访问同一个记录时的行为。  
>
>优点：
>
>> 读写互不阻塞，提高并发性能  
>> 降低死锁风险
>
>缺点:
>
>> 不能解决幻读的问题。原因是MVCC前提是数据存在，  
>> 幻读发生在新增和删除时
>
>|        | 实现方式                   | 应用                                                         |
>| ------ | -------------------------- | ------------------------------------------------------------ |
>| 当前读 | next-key lock & 间隙锁     | `SELECT ... LOCK IN SHARE MODE`<br />`SELECT ... FOR UPDATE`<br />`UPDATE ...`<br />`DELETE ...`<br />`INSERT ...` |
>| 快照读 | Consisent Read View & MVCC |                                                              |
>
>
>
>> 实现方式：
>> 应用：

#### 5.5 <a id="un-re-do-log">UndoLog  & RedoLog 工作原理</a>

> 1. Undolog作用:
>
>原理：
> 
>> 记录一行数据每一次更新操作产生的一个 roll_pointer 指针和一个 trx_id 事务id  
>> 变更数据格式：`|变更行记录|trx_is|roll_pointer|`
>
>作用
>
>> **实现事务回滚，保障事务的原子性**  
>> **实现 MVCC（多版本并发控制）关键因素之一**
>
> 2. 事务提交前将log buffer中数据刷新到磁盘
>
> ![](https://i-blog.csdnimg.cn/blog_migrate/0fc1a1798d2860a16aeef31d03f0268c.png)



#### 5.6 UndoLog  & RedoLog & BinLog 区别

### 6. 基础使用

#### 6.1 分页查询



### 综合使用

#### 1. 性能优化

1. 慢查询优化

   > - 开启long_query_time、log-queries-not-using-indexs、show_query_log
   > - 使用慢查询功能，获取查询时间较长的sql`show variables like "%slow_query%";`
   > - 使用explain命令查询问题SQL执行计划
   > - 使用show profiles查看问题sql的性能情况
   > - 优化sql语句

2. join优化原则：

   > - 驱动表和小表，减少外层循环次数
   > - 为匹配条件增加索引（减少内层表的循环匹配次数）
   > - 增大join buffer size大小（一次缓存的数据越多，内层表的扫描次数越少）
   > - 减少不必要的字段查询（字段越少， join buffer所缓存的数据就越多）

3. in优化：子查询中结果集较少，主查询数据比较大，并且有索引

4. exists优化：子查询结果较多，主查询数据少

5. order by优化：由max_length_for_sort_data参数决定，排序单条记录字段长度 <=， 用全字段排序，反之用rowID

6. **索引优化：(空间换时间， 减少磁盘IO次数)**

   > 1. 使用联合索引进行索引覆盖，避免回表， 5.6 增加了**索引下推**优化
   > 2. 查询中使用最左匹配走最左匹配
   > 3. 联合索引创建原则：使用频繁，区分度高（筛选粒度大）
   > 4. 不要在索引列上做任何计算

#### 2.  查询Mysql使用经验

1. [explain](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)命令

   | 参数 | 含义                       |
   |----| -------------------------- |
   | id  | 表的读取顺序               |
   | select_type | 数据读取操作的操作类型 |
   | possible_keys | 哪些索引可以使用 |
   | key | 哪些索引被实际使用         |
   | ref | 表之间的引用               |
   | rows | 每张表有多少行被优化器查询 |

### 面试题

1. 如何保证事务一致性？

2. Mysql间隙锁应用方式？

3. 什么是回表？产生mysql回表的几种情况？如何避免回表？

4. 哪些情况会[索引失效](https://cloud.tencent.com/developer/article/1992920)情况

   > - 不满足最左匹配原则：`where 中没有最左项`
   > - 范围查询**之后**的索引字段：`where demo_col > 1 and index_demo=1`
   > - 索引字段做运算或使用了函数
   > - 避免使用SELECT  * : `不会走索引覆盖`
   > - or分割的条件不满足 ： `有一个没索引就都失效`   `or两边加了> he < 范围查询`
   > - LIKE查询 %开头
   > - 参数类型与字段类型不匹配，导致类型发生了隐式转换，索引失效：`int类型加了''变为了字符串`
   > - 两个列做比较
   > - is not null 不走索引：`is null时可以走索引`
   > - 查询条件是字符串使用 != 或 <>可能会不走： `id != 条件会走`
   > - 查询条件使用not in时，普通索引索引失效：`如果是主键则走索引`
   > - order by 或 limit 未索引覆盖时可能会失效：`索引覆盖可以走`