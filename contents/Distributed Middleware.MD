# 分布式

### 分布式基础理论

#### 1. CAP理论

一致性（Consisency）
可用性（Availability）
分区容错性（Partition tolerance）



### 分布式ID服务架构

#### 1. 雪花算法

- 架构图

  <img src="../pictures/architecture/snow algorithm archistruct.png" style="zoom:67%;"/>

### 分布式锁

https://www.cnblogs.com/liuqingzheng/p/11080501.html

#### 1. 解决方案

- 基于数据库实现分布式锁
- 基于缓存（Redis等）实现分布式锁
- 基于Zookeeper实现分布式锁

#### 2. 设计需要考虑点

- **高性能**：在分布式环境中，网络通信的性能损耗比单机环境大，分布式锁的设计需要尽量减少对系统性能的影响。
- **高可用性**：分布式锁服务需要保证高可用性，避免因为服务不可用导致整个系统不可用。
- **锁失效机制**：为了避免应用程序因为故障而未能释放锁，需要设计超时机制来确保锁在一定时间后被自动释放，防止死锁的发生。
- **非阻塞特性**：业务逻辑需要考虑锁是否被立即获取，对于不能立即获取锁的情况，需要支持非阻塞等待或立即返回。

### 分布式事务

#### 1. Saga

- 两种协调逻辑：编排 和 控制，  
- 两种恢复模式：向前恢复和向后恢复，  
- 适用场景：适用调用链路比较长  

#### 2. TCC（Try Confirm Cancel) 

- 适用场景：资金数据，银行业务，金融业务，涉及到交易、支付、账务，**超卖**，都可以考虑。  
- 缺点：业务侵入比较大  

#### 3. 2PC

# 中间件

### Kafka

#### 1.保证可靠性

Kafka Send 提供了三种不同的发送确认机制，以确保消息的可靠性。

1. 同步发送（Synchronous Send）：Producer 会等待 Kafka 确认消息已经被成功写入到本地 Broker 之后才会继续执行后续操作。这种方式可以保证消息一定会被写入到 Kafka，但可能会降低吞吐量。
2. 异步发送（Asynchronous Send）：Producer 不会等待 Kafka 的确认消息，而是直接返回一个发送结果。如果消息发送失败，Producer 可以根据返回的错误信息进行重试或者其他处理。这种方式可以提高吞吐量，但无法保证消息一定会被写入到 Kafka。
3. 幂等性发送（Idempotent Send）：在幂等性发送模式下，Kafka 会为每个主题分配一个唯一的序列号，Producer 在发送消息时会包含这个序列号。如果消息已经被写入到 Kafka，那么 Kafka 会认为这是一个重复的消息，并忽略它。这种方式可以确保消息不会重复写入到 Kafka，但需要额外的逻辑来处理重复的消息。

要确保 Kafka Send 的可靠性，建议采用以下策略：

1. 使用同步发送或幂等性发送模式，以确保消息一定会被写入到 Kafka。
2. 配置 Producer 的重试次数和重试间隔，以便在发送失败时能够自动重试。
3. 使用幂等性生产者（Idempotent Producer），确保即使消息重复发送也不会导致数据不一致。
4. 配置 Kafka 的副本因子（Replication Factor），以提高数据的可靠性和容错能力。
5. 定期监控 Kafka 集群的健康状况和性能指标，及时发现并解决问题。

2.

### RocketMQ

### Seata

