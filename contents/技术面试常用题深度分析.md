牛逼面试：[Java 高级面试题 | 弟弟快看-教程 (ddkk.com)](https://www.ddkk.com/zhuanlan/newtiku/java.html)

# JAVA基础

#### 数据结构

1. HashMap：

   - 工作原理：

   - 链表插入算法：头插法和尾插法

   - 红黑树：红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题。

   - 扩容条件：

     1.  存放新值的时候当前已有元素的个数必须**大于等于**阈值

        16（默认数组大小）* 0.75（默认装载因子） = 12(扩容threshold)

     2. `在JDK7版本 ：存放新值的时候当前存放数据发生hash碰撞`

     扩容方法与规则：resize() 方法，将 table 长度变为原来的两倍

     缩容条件：**小于**阈值

   - 链表 -> 红黑树条件：链表中的节点数量>8 且 当前数组中的长度 > MIN_TREEIFY_CAPACITY(默认值64)

     红黑树 -> 链表条件：链表中的节点数量<= 6，且只有在resize的时候才会根据 UNTREEIFY_THRESHOLD 进行转换。

   - 资料
     - [大厂必备HashMap夺命连环问](https://zhuanlan.zhihu.com/p/410319925)
     - [【java集合】Collection和Map](https://zhuanlan.zhihu.com/p/88576028)
     - [Java并发编程中的HashMap、HashTable、ConcurrentHashMap_java map并发问题-](https://blog.csdn.net/weixin_41733225/article/details/131588180)

   - JDK7因为顺序问题会陷入死循环，扩容时即新链表会反转链表元素顺序，JDK8 使用head 和tail保证链表顺序

   - HashCode 与 equals重写

     Key key1 = new Key(1);

     Key key2 = new Key(1);

     **hashCode函数核心逻辑**

     hashcode函数返回Object对象内存地址， equals函数默认返回内存地址值。

     当向HashMap中存入k1的时候，首先会调用Key这个类的hashcode方法，计算它的hash值，随后把k1放入hash值所指引的内存位置，

     在Key这个类中没有定义hashcode方法，就会调用Object类的hashcode方法，

     而Object类的hashcode方法返回的hash值是对象的地址。
     
     这时用k2去拿也会计算k2的hash值到相应的位置去拿，
     
     由于k1和k2的内存地址是不一样的，所以用k2拿不到k1的值
     
     **equals函数核心逻辑**
     
     重写hashcode方法仅仅能够k1和k2计算得到的hash值相同，调用get方法的时候会到正确的位置去找，
     
     但当出现散列冲突时，在同一个位置有可能用链表的形式存放冲突元素，这时候就需要用到equals方法去对比了，
     
     由于没有重写equals方法，它会调用Object类的equals方法，
     
     Object的equals方法判断的是两个对象的内存地址是不是一样，
     
     由于k1和k2都是new出来的，k1和k2的内存地址不相同，所以这时候用k2还是达不到k1的值
     
     **什么时候需要重写hashcode和equals方法**
     
     在HashMap中存放自定义的键时，就需要重写自定义对象的hashcode和equals方法

2. List：

   - ArrayList扩容机制

     因为采用无参构造方法创建的ArrayList底层数组大小默认为10，所以这里我们就以数组大小10为例，当我们新增元素的时候发现数组已经满了，此时它会重新定义一个大小为10+10/2（增加原来的0.5倍 ），如果是使用有参构造方法创建的，扩容也会根据指定大小进行扩容，规则是一样的。

   - LinkedList数据结构

     双向链表



#### 泛型

Java中的泛型是一种允许在编译时对类型进行参数化的特性。泛型的优势包括：

- **类型安全：** 泛型提高了代码的类型安全，通过在编译时进行类型检查，减少运行时错误。

- **代码重用：** 泛型使得类和方法能够处理不同类型的数据，提高了代码的可重用性。

- **消除类型强制转换：** 使用泛型可以减少显式的类型转换，代码更加清晰、易于理解。

- **泛型算法：** 使得算法可以独立于数据类型，增加了算法的通用性和灵活性。

- **与集合框架的集成：** Java的集合框架广泛使用泛型，提高了集合操作的类型安全和易用性。



#### 类加载与执行

- 类加载时机

  由虚拟机决定，有且只有5种情况必须对类初始化（深入了解java虚拟机P210）

- 类加载过程与加载顺序：共七个阶段， 加粗部分称为**连接（Linking）**。

  1. 加载：通过获取全限定名获取二进制流，将静态存储结构转化为 **方法区** 运行时数据结构 ，内存生成java.lang.Class对象。

  2. **验证**：确保Class文件字节流中包含的信息符合当前JVM要求，进行文件格式验证，元数据验证，字节码验证，符号引用验证。

  3. **准备**：为类变量分配内存并设置`类变量`(被static修饰的变量)初始值， 变量所使用内存都在方法区中分配。

  4. **解析**：将常量池中的符合引用替换为直接引用的过程

  5. 初始化：

     执行类构造器<clinit>()方法的过程， 

     clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，

     执行顺序 父类静态 > 子类静态 > 父类构造 > 子类构造

  6. 使用

  7. 卸载

     - 触发条件：当一个类的ClassLoader实例被回收，同时该类没有任何活跃的实例，且没有其他地方引用该类的方法或变量时，这个类就会被卸载。

     - 回收过程：类的卸载发生在垃圾收集过程中。

     - 重要性：在使用自定义类加载器频繁加载和卸载类的场景中，类卸载机制特别重要，以避免内存泄漏。

- 类加载器

  1. 主要按层次分为两类，启动类加载器和其他类加载器。其他类加载器分为扩展类加载器，应用程序类加载器， 自定义类加载器

  2. ClassLoader.loadClass()方法，

     双亲委派模型工作原理：所有类加载器收到类加载时指派给父类进行加载，当父类加载器反馈无法加载时，才由子类加载器进行加载。

- 类实例化方式

  

#### 常用对象

String与StringBuffer与StringBuilder





#### 函数复杂度与性能评估





#### 反射及用途

Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。

对于任意一个对象，都能够调用它的任意一个方法和属性。

这种动态获取信息以及动态调用对象的方法的功能称为Java语言的反射机制。

主要包括以下内容：

**1、获取Class对象的三种方式：** 直接通过对象调用getClass()方法，使用Class类的静态方法forName(String className)，或者通过类名.class属性。

**2、创建对象：** 通过Class对象的newInstance()方法创建其对应类的实例。

**3、获取方法：** 使用Class对象的getDeclaredMethods()方法获取类内定义的所有方法。

**4、访问字段：** 使用Class对象的getDeclaredFields()方法访问类内定义的字段。

**5、调用方法：** 通过Method对象的invoke()方法调用具体的方法。



#### JVM

![Java 基础：JVM虚拟机结构_java jvm结构-CSDN博客](https://tse2-mm.cn.bing.net/th/id/OIP-C.uSpGgSRF7zg2l17nuQghCgHaGq?rs=1&pid=ImgDetMain)

- 运行时内存数据区域

  元空间：动态扩容，会导致堆申请失败

  线程共享：

  - 堆（Heap）
  - 方法区(Method Area)：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（动态代理生成的类信息）等数据。
  - 运行时常量池：方法区的一部分，用于存储编译期生成的各种字面量和符号引用。

  线程隔离：

  - 虚拟机栈（VM Stack， 由栈帧组成）

    **栈帧**：**每个方法执行同时会创建一个栈帧**

    - 含局部变量表：是一组变量值存储空间。单位是变量槽Slot，数据类型为32位以内的数据变量， 包括boolean, byte, char, short, int, float,reference,returnAddress 

    - 操作数栈：任意数据类型，方法刚开始执行为空，过程中字节码指令进行入栈出栈

    - 动态连接：每个栈帧包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中动态连接

    方法返回地址等。 

  - 本地方法栈(Native Method Stack)：为虚拟机使用到的Native方法服务。

  - 程序计数器(Program Counter Register)：当前线程所执行的字节码的行号指示器。

- java 垃圾回收机制

  - 回收算法 &工作原理
    1、标记-清除算法（Mark-Sweep）： 首先标记出所有活动的对象，然后清除所有未标记的对象。
    2、复制算法（Copying）： 将内存分为两块，每次只使用其中一块。当这一块的内存用完后，将活动的对象复制到另一块上，然后清理已使用的内存块。
    3、标记-整理算法（Mark-Compact）： 类似于标记-清除算法，但在清除前，将所有存活的对象向一端移动，然后清理边界以外的内存。
    4、分代收集算法（Generational Collection）： 将堆分为几个区域（如新生代、老年代），根据对象的存活周期使用不同的收集算法。
  - 收集器类型
    1. Serial收集器：它是一个单线程收集器，工作时会暂停所有其他工作线程（"Stop-The-World"），它的优点是简单高效（与其他收集器的单线程比），适用于单核处理器的环境。
    2. ParNew收集器：可以看作是Serial收集器的多线程版本，主要用于新生代的垃圾收集，适合多核处理器环境。
    3. Parallel Scavenge收集器：也是一个新生代垃圾收集器，使用多线程收集，注重吞吐量（CPU用于运行用户代码的时间比率）。
    4. Serial Old收集器：是Serial收集器的老年代版本，单线程，采用标记-整理算法。
    5. Parallel Old收集器：是Parallel Scavenge收集器的老年代版本，使用多线程并行收集，目标是提高系统吞吐量。
    6. CMS（Concurrent Mark Sweep）收集器：以获取最短回收停顿时间为目标，使用多线程并发标记和清除算法。
    7. G1（Garbage-First）收集器：采用分区堆（Heap）和增量式垃圾回收，目标是兼顾吞吐量和停顿时间。
    8. 

- 字节码执行引擎

  - 字节码指令只针对当前栈帧有效，编译程序代码时已确定并写入方法表Code属性。

- 逃逸分析

  - 基本行为就是分析对象动态作用域。
  - 两类逃逸： 方法逃逸和线程逃逸。

- 对象结构之对象头（Mark Word）

  ![image-20231230141221028](C:\Users\micang\AppData\Roaming\Typora\typora-user-images\image-20231230141221028.png)

#### JMM

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219191643235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center)

- 定义：Java内存模型(Java Memory Model)。在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

- 参考资料：

  [面试官：你竟然不知道JMM？JVM和JMM傻傻分不清 ](https://zhuanlan.zhihu.com/p/136623445)

  [面试系列之-总线锁和缓存锁相关（JAVA基础）-腾讯云开发者社区-volatile实现底层原理](https://cloud.tencent.com/developer/article/2327829)

  [一文搞定JMM(java内存模型) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/455820119)

- JMM中规定**8种**内存交互操作

  每种操作都有自己作用的的区域，具体操作如下：

  1. lock（锁定）：作用于**主内存的变量**，把一个变量标识为线程独占状态。

  2. unlock（解锁）：作用于**主内存的变量**，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

  3. read （读取）：作用于**主内存变量**，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。

  4. load（载入）：作用于**工作内存的变量**，它把read操作从主存中变量放入工作内存中。

  5. use（使用）：作用于**工作内存中的变量**，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令。

  6. assign（赋值）：作用于**工作内存中的变量**，它把一个从执行引擎中接受到的值放入工作内存的变量副本中。

  7. store（存储）：作用于**主内存中的变量**，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。

  8. write（写入）：作用于**主内存中的变量**，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

     ![img](https://pic1.zhimg.com/80/v2-36d9a02a865f290497c38689a949ebcc_720w.webp)

     `在多CPU环境下，其中‘缓存一致性协议’通过cpu高速缓存（三级缓存L1, L2，L3）来实现，同时引出总线锁，因为总线锁的效率问题，引出缓存锁，即保证缓存数据一致性`

- mesi协议：[缓存一致性协议硬核讲解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/375706879)

  - 缓存行四大状态：

    Modified（被修改）：当前 CPU 缓存有最新数据， 其他 CPU 拥有失效数据，当前 CPU 数据与内存不一致，但以当前 CPU 数据为准。

    Exclusive（独享的）：只有当前 CPU 有数据，其他 CPU 没有该数据，当前 CPU 数据与内存数据一致。

    Shared（共享的）：当前 CPU 与其他 CPU 拥有相同数据，并与内存中数据一致。

    Invalid（无效的）：当前 CPU 数据失效，其他 CPU 数据可能有可能无，数据应从内存中读取，且当前 CPU 与 内存数据不一致。

  - 两大特性：

    写传播：嗅探和基于目录

    写串行化

  - 严格按照 MESI 协议，会有严重的性能问题， 

    在 MESI 中，依赖总线嗅探机制，整个过程是串行的，可能会发生阻塞。

    解决上面两个问题，引入了写缓冲区（Load Buffer）和失效队列（Invalid Queue）

  - 引入了写缓冲区（Load Buffer），即使读写指令本身是按照顺序执行的，但最终仍然可能会乱序执行。

    解决上面问题，使用CPU 内存屏障

  - 内存屏障

    内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障

    两个作用：

    - 阻止屏障两侧的指令重排序；
    - 强制把写缓冲区/高速缓存中的数据等写回主内存，让缓存中相应的数据失效。

#### JVM与JMM关系

参考阅读：[【JVM】JMM与JVM关系（附整体架构图）_jvm和jmm的关系](https://blog.csdn.net/qq_33762302/article/details/113970367)

JMM 只是一个抽象模型，而 JVM 是一个具体的实现。

> PS：可以理解成JMM是MVC，JVM是SSM

- 内存 => JVM 堆内存 + 方法区（运行时数据区的线程共享部分）
- 工作空间 => 程序计数器 + Java 栈 + 本地方法栈（运行时数据区的线程私有部分）
- 线程 => 执行引擎（相当于 CPU）

#### java 异常处理

可参考：[Java中八个常见异常中文解释和异常原因解析](https://blog.csdn.net/CKApril_java/article/details/106744837)

- 编译时抛出异常（check）
  ClassNotFoundException
  CloneNotSupportedException
- 运行时抛出异常（uncheck）
  RunTimeException（以下五种异常都属于运行时异常）
  ArithmeticException
  NullPointerException
  ArrayIndexOutOfBoundsException
  ClassCastException
  NumberFormatException

#### JDK8新特性

- 异步实现方式：**CompletableFuture**，它是ExecutorService接

- 口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程

- 数组排序：

  ```text
  正序：list.sort((User u1, User u2) -> u1.getAge().compareTo(u2.getAge()));
  倒序：list.sort(Comparator.comparing(User::getAge).reversed());
  组合排序：list.sort(Comparator.comparing(User::getAge).thenComparing(User::getName));
  ```

- 数组转Map

  list.stream().collect(Collectors.toMap(Account::getId, Account::getUsername))

- 数组分组：

  . collect(Collectors.groupingBy(Person::getAge))

#### 面试常问问题

##### 1. finally 一定会被处理吗

多数情况下会，但是有例外，例如System.exit ()方法，Thread.stop ()方法， JVM错误终止导致未执行到finally

##### 2. final, finally和finalize的区别

final: java关键字，可做用于方法，变量，类， 被final声明后只能使用，即不能修改。

finally：是在异常处理时提供finally块来执行任何清除操作。

finalize：方法，finalize() 是在垃圾收集器删除对象之前对这个对象调用的。 

##### 3. 装箱与拆箱及向上向下转型

- 装箱与拆箱定义：在许多情况下包装与解包装是由编译器自行完成的（在这种情况下包装称为装箱，解包装称为拆箱），.valueOf() 和 .initValue()方法。
- 作用：为了保证通用性和提高系统性能

- “==” 和 equals()比较

  1. 基本型和封装类型进行"=="运算符的比较，封装类型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较。

  2. 两个Integer类型进行"=="比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关。

     缓存范围可通过Integer.IntegerCache.high这个属性配置， VM参数里为-XX:AutoBoxCacheMax=2000进行设置调整。

- **向上转型**：将子类对象转为父类对象，父类对象可以是接口

- **向下转型**：把父类对象转为子类对象，转化后的子类对象，跟一般的继承子类对象一样

##### 4. Java中的内存泄漏及防止

长生命周期的对象持有短生命周期对象的引用，导致短生命周期对象不能被垃圾回收器回收

##### **5. JVM的永久代（PermGen）和元空间（Metaspace）区别**

永久代（PermGen）和元空间（Metaspace）是JVM中存储类元数据的区域，二者的主要区别如下：
1、存储位置：永久代是在JVM的堆内存中，而元空间位于本地内存。
2、大小限制：永久代的大小是固定的，容易出现内存溢出；元空间利用本地内存，所以默认情况下只受本地内存大小限制。
3、回收机制：永久代的回收主要针对常量池的回收和对类型的卸载；元空间提供了更好的性能，在使用本地内存的同时，减少了垃圾收集的频率。

##### 6. JVM在对象分配内存时的策略

1. 对象首次分配： 新创建的对象首先在堆内存的年轻代中分配空间。年轻代主要包括Eden区和两个Survivor区。大部分情况下，对象最初被分配在Eden区。

2. 小对象与大对象： 小对象在年轻代中分配，而大对象(1.8默认0， 当 Survivor 区域空间不足)可能直接在老年代，避免频繁复制。

   `-XX:PretenureSizeThreshold=1048576参数可设置`

3. 年龄判断和晋升： 对象在年轻代中每经历一次垃圾回收仍然存活，其年龄就会增加。达到**阈值(默认：15)**，晋升到老年代。

4. 内存分配失败处理： 如果在年轻代中无法为新对象找到足够空间，JVM将触发一次Minor GC。如果GC后仍无法满足内存需求，对象可能直接在老年代中分配。

#### Java 代理模式

[太好了！总算有人把动态代理、CGlib、AOP都说清楚了！-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1461796)

[Java的三种代理模式 - 洋葱源码 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cenyu/p/6289209.html)

- 静态代理：

  缺点：接口变更导致维护成本非常大

  优点：使得真实主题处理的业务更加纯粹，不再去关注一些公共的事情，公共的业务由代理来完成。

- jdk动态代理

  实现方式：

  ```
  public class ProxyFactory{
      private Object target;
      
      public ProxyFactory(Object target){
          this.target=target;
      }
  
      public Object getProxyInstance(){
          return Proxy.newProxyInstance(
                  target.getClass().getClassLoader(),
                  target.getClass().getInterfaces(),
                  new InvocationHandler() {
                      @Override
                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                          Object returnValue = method.invoke(target, args);
                          return returnValue;
                      }
                  }
          );
      }
  
  }
  ```

  缺点：真实主题必须实现主题接口，没有主题接口则不能生成代理对象

  优点：1.相比于静态代理，不需要写一个形式上完全一样的封装类，减少维护成本。 2.制定代理类的执行逻辑

- CGLIB动态代理：

  实现方式：

  ```
  public class ProxyFactory implements MethodInterceptor{
      private Object target;
      
      public ProxyFactory(Object target) {
          this.target = target;
      }
  
      public Object getProxyInstance(){
          Enhancer en = new Enhancer();
          en.setSuperclass(target.getClass());
          en.setCallback(this);
          return en.create();
      }
  
      @Override
      public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable     {
        Object returnValue = proxy.invokeSuper(obj, args);
        return returnValue;
      }
  }
  ```

  缺点：基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可

  优点：不要真实主题接口，直接代理真实主题类
  
  底层：Asm字节码增强技术， 使用FastClass基础解决反射带来的性能问题
  
  



# 多线程与并发

#### 线程安全三要素

1. 可见性：volatile，synchronized，lock

   - volatile关键字很重要的两个特性:
     - 保证变量在线程间可见，对volatile变量所有的写操作都能立即反应到其他线程中，换句话说，volatile变量在各个线程中是一致的（得益于java内存模型—"先行发生原则"）；
     - 禁止指令的重排序优化；

2. 有序性：volatile，synchronized，lock

3. 原子性：synchronized，lock

4. 判定数据是否存在竞争和线程是否安全的主要依据：先行发生原则。

   先行发生定义： java内存模型中定义的两项操作之间的偏序关系。

   java 中定义的先行发生原則（happens-before）：

   - 程序次序规则： 一个线程内保证语句的执行顺序。
   - 管程锁定规则：解锁一个锁之前的操作对于接下来对这个锁的加锁操作是可见的。
   - volatile变量规则：对一个volatile变量的写操作对后续对这个变量的读操作是可见的。
   - 线程启动规则：Thread对象的start()方法happens-before该线程的每个动作。
   - 线程终止规则：线程中的所有操作都happens-before其他线程检测到这个线程已经终止，通过Thread.join()方法或者isAlive()的返回值。
   - 线程中断规则
   - 对象终结规则
   - 传递性：如果操作A happens-before B，且B happens-before C，则A happens-before C。

#### volatile关键字

原理

- 规定线程每次修改变量副本后**立刻同步到主内存**中，用于保证其它线程可以看到自己对变量的修改

- 规定线程每次使用变量前，先从主内存中**刷新最新的值**到工作内存，用于保证能看见其它线程对变量修改的最新值

- 为了实现可见性内存语义，编译器在生成字节码时，会在指令序列中插入**内存屏障**来**防止指令重排序**。
- 解决可见性和有序性。

注意：

- 只解决了可见性问题，没有解决原子性问题
- 只对基础数据类型生效，并未解决对引用对象的实际对象数据的可见性

volatile关键字使用条件

- 变量不依赖于其当前值，或者只有单一的线程修改变量的值。
- 变量没有包含在具有其他变量的不变式中。

#### 线程池参数

#### 如何手动实现多线程

#### 线程池类型和应用场景

#### ThreadLocal使用方式

#### 线程与进程

#### Notify与wait

用于线程间的协作，控制线程的等待和唤醒。使用方式：

- wait()：调用`wait()`使当前线程等待，直到其他线程调用此对象的`notify()`或`notifyAll()`方法。

- notify()：唤醒在此对象监视器上等待的单个线程。

- 同步块内使用：`wait()`和`notify()`必须在同步块或同步方法内部使用。

- 释放锁：调用`wait()`会释放锁，而`notify()`不会释放锁。
- 存在的问题及解决方案：[求求你，别再用wait和notify了](https://www.cnblogs.com/vipstone/p/14136973.html)
  - 问题：**所谓的线程“假死”是指，在使用 `notify` 唤醒多个等待的线程时，却意外的唤醒了一个没有“准备好”的线程，从而导致整个程序进入了阻塞的状态不能继续执行。**
  - 解决方案：使用**Condition**类



#### 锁

1. 对象加锁过程

   [Java对象头MarkWord探索](https://www.jianshu.com/p/d48c9b0fc1b4)

   [Java程序员装X必备词汇之Mark Word](https://zhuanlan.zhihu.com/p/399423994)

2. 锁类型

   [Java中的锁分类 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/112649693#:~:text=Java中的锁分类 1 1、乐观锁 %26 悲观锁 两种锁只是一种概念 ... 2,重量级锁 JDK 1.6 为了减少获得锁和释放锁所带来的性能消耗，在JDK 1.6里引入了4种锁的状态： 无锁、偏向锁、轻量级锁和重量级锁 ，它会随着多线程的竞争情况逐渐升级，但不能降级。 )

   - **乐观锁：**乐观锁认为一个线程去拿数据的时候不会有其他线程对数据进行更改，所以不会上锁。

     实现方式：CAS机制、版本号机制

     **悲观锁：**悲观锁认为一个线程去拿数据时一定会有其他线程对数据进行更改。所以一个线程在拿数据的时候都会顺便加锁，这样别的线程此时想拿这个数据就会阻塞。比如Java里面的synchronized关键字的实现就是悲观锁。

     实现方式：就是加锁。

   - **独享锁：**该锁一次只能被一个线程所持有， Synchronized（可重入，互斥锁），ReentrantLock（互斥锁，可重入），读写锁ReentrantReadWriteLock写锁WriteLock

     **共享锁：**该锁可以被多个线程所持有，读写锁ReentrantReadWriteLock读锁ReadLock

     通过AQS实现

   - ##### 可重入锁

     定义：对于同一个线程在外层方法获取锁的时候，在进入内层方法时也会自动获取锁。

     优点：避免死锁

     举例：ReentrantLock、synchronized

   - 分段锁：当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。CurrentHashMap底层就用了分段锁

   - **公平锁：**多个线程相互竞争时要排队，多个线程按照申请锁的顺序来获取锁。

     **非公平锁：**多个线程相互竞争时，先尝试插队，插队失败再排队，比如：synchronized、ReentrantLock

3. 锁的升级和降级

   **无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁**。它会随着多线程的竞争情况逐渐升级，但不能降级。

   研究发现大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了不让这个线程每次获得锁都需要CAS操作的性能消耗，就引入了偏向锁。当一个线程访问对象并获取锁时，会在对象头里存储锁偏向的这个线程的ID，以后该线程再访问该对象时只需判断对象头的Mark Word里是否有这个线程的ID，如果有就不需要进行CAS操作，这就是偏向锁。当线程竞争更激烈时，偏向锁就会升级为轻量级锁，轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式等待一会儿上一个线程就会释放锁，但是当自旋超过了一定次数，或者一个线程持有锁，一个线程在自旋，又来了第三个线程访问时（反正就是竞争继续加大了），轻量级锁就会膨胀为重量级锁，重量级锁就是Synchronized,重量级锁会使除了此时拥有锁的线程以外的线程都阻塞。

4. Synchronized 与 BeentrantLock


| 锁类型 | 锁名称       | 修饰范围                                | 原理                                                         | 数据存储                        |
| ------ | ------------ | --------------------------------------- | ------------------------------------------------------------ | ------------------------------- |
| 显式   | synchronized | 对象， 成员方法，静态方法（对象.class） | 当方法调用时， 检查ACC_SYNCHRONIZED是否设置，如果设置，则要求持有管程，结束后释放管程 | 对象头（mark word），方法常量池 |
|        |              | 代码块                                  | 通过monitorenter和monitorexit指令集进行控制                  |                                 |
|        |              |                                         |                                                              |                                 |
| 隐式   | ReentranLock |                                         | AQS， 存储：线程存储(双向链表)，阻塞与释放：阻塞与唤醒（LockSupport.park() 与 LockSupport.unpark() ） |                                 |
|        |              |                                         |                                                              |                                 |

5. AtomicInteger实现原理：[原子操作类AtomicInteger](https://blog.csdn.net/fanrenxiang/article/details/80623884)

6. 死锁：子类改写父类synchronized方法，并且引用父类中的方法， 使用可重入锁即可解决 

7. Java中的CAS（`Compare-And-Swap`）操作是什么？它如何实现无锁编程？[并发编程的灵魂：CAS机制详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/101430930)

   - 原子操作：**只能保证共享变量操作的原子性，而不能保证代码块的原子性。**

     CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值（B）。

     如果内存位置的值与预期原值相同，那么处理器会自动将该位置值更新为新值。

   - 无锁优势：可以在不使用传统锁的情况下实现线程安全。减少线程阻塞，提高系统吞吐量。

   - ABA问题：即值原来是A，变成了B，后又变回A，CAS会误认为值没有改变。可以通过版本号等机制解决。

8. JAVA中AQS（`AbstructQueuesSyschronized`）

   - 参考连接：[Java并发之AQS详解 - 掘金 (juejin.cn)](https://juejin.cn/post/7006895386103119908)

   - 定义：

     `AQS`通过一个`FIFO`队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制。

     同时其定义`Condition`结构提供了`wait/signal`等待唤醒机制。

     在`JUC`中，诸如`ReentrantLock`、`CountDownLatch`等都基于`AQS`实现。

   - 原理：

     AQS维护了一个`volatile int state`变量和一个`CLH(三个人名缩写)双向队列`，

     队列中的节点持有线程引用，每个节点均可通过`getState()`、`setState()`和`compareAndSetState()`对`state`进行修改和访问。·
     
     <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e22dfb7003ee44afb6f80ddfbce68a93~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" style="zoom:50%;" />
     
   - 解决了有序性（双向链表，使用HEAD & TAIL保证顺序）和可见性（state变量使用volatile关键字）

#### 发布与逸出

避免逸出方式当且仅当对象的构造函数返回时对象才处于可预测的和一致的状态。

#### 常见面试题

##### 1. Java中，如何正确地处理并发问题？

处理Java中的并发问题通常涉及以下几个关键步骤：
1、使用同步机制： 如synchronized关键字、ReentrantLock等，确保共享数据在多线程之间正确访问。
2、使用并发集合： 如ConcurrentHashMap, CopyOnWriteArrayList等，这些集合类是为并发环境优化的。
3、使用原子类： 如AtomicInteger等，提供无锁的线程安全操作。
4、使用线程池： 管理线程生命周期，避免创建过多的线程导致资源浪费。
5、避免死锁： 识别和避免死锁的常见模式，比如避免嵌套锁，使用锁顺序等。

##### 2. Java中如何实现线程间的通信？

在Java中，线程间通信主要依赖以下几种机制：
1、等待/通知机制： 使用Object类的wait(), notify()和notifyAll()方法来实现线程之间的等待和通知。
2、使用管道通信： 通过PipedInputStream和PipedOutputStream或者PipedReader和PipedWriter实现线程间的数据传输。
3、使用阻塞队列： 如ArrayBlockingQueue、LinkedBlockingQueue等，线程可以安全地从队列中添加或移除元素。
4、使用信号量： Semaphore可以控制对共享资源的访问。
5、利用并发工具类： 如CyclicBarrier, CountDownLatch, Exchanger等，这些工具类提供了更高层次的线程间协调功能。

##### 3. 讲述Java中的Lock接口及其与synchronized的区别。

- 显式锁定： Lock是一个接口，提供了比synchronized更灵活的锁定机制。
- 可中断锁定： Lock允许尝试非阻塞地获取锁，或者在锁定期间响应中断。
- 公平性选择： Lock提供了选择公平锁或非公平锁的能力。
- 性能差异： 在不同情况下，Lock和synchronized的性能表现有所不同。

##### 4. Java中synchronized和ReentrantLock有什么区别？

Java中synchronized和ReentrantLock的区别主要体现在以下几个方面：
- 锁的实现方式：synchronized是Java内置的关键字，JVM层面实现；ReentrantLock是Java类库中的一个API。
- 锁的公平性：synchronized不保证公平性；而ReentrantLock可以通过构造函数设置公平性。
- 锁的灵活性：ReentrantLock提供更灵活的锁操作，它支持中断锁的获取、超时获取锁等高级功能。
- 条件变量支持：ReentrantLock可以与Condition类配合，实现分组唤醒等复杂的线程协作。

#### Spring Boot 异步线程间数据传递

TaskDecorator 与 TransmittableThreadLocal

参考：https://segmentfault.com/a/1190000043426390



# 常用设计模式

Java中的设计模式主要分为三大类：创建型、结构型和行为型。
1、创建型模式
这些模式提供了创建对象的机制，增加已有代码的灵活性和可重用性。
例如，**单例模式（Singleton）**、工厂方法模式（Factory Method）、**抽象工厂模式（Abstract Factory）**、建造者模式（Builder）和原型模式（Prototype）。
2、结构型模式
这些模式关注如何组合对象和类形成更大的结构。
例如，**适配器模式（Adapter）**、桥接模式（Bridge）、组合模式（Composite）、装饰器模式（Decorator）、外观模式（Facade）、享元模式（Flyweight）和**代理模式（Proxy）**。
3、行为型模式 
这些模式特别关注对象之间的通信。
例如，**责任链模式（Chain of Responsibility）**、命令模式（Command）、解释器模式（Interpreter）、迭代器模式（Iterator）、中介者模式（Mediator）、备忘录模式（Memento）、**观察者模式（Observer）**、状态模式（State）、**策略模式（Strategy）**、模板方法模式（Template Method）和访问者模式（Visitor）。



# Spring系列

#### SpringMvc 流程

1. 请求到达DispatcherServlet： 所有请求首先到达中央控制器DispatcherServlet。

2. 请求映射： DispatcherServlet调用HandlerMapping确定请求的处理器。

3. 调用处理器： 处理器接收请求并返回ModelAndView对象。

4. 视图解析： DispatcherServlet调用ViewResolver来解析Handler返回的视图。

5. 返回响应： 视图负责渲染并返回给客户端。

   Spring MVC通过这种流程提供了一个灵活、解耦的方式来开发Web应用。

<img src="https://img-blog.csdnimg.cn/20210306223048434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzYwMTM1OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

#### bean 初始化流程

<img src="https://img-blog.csdnimg.cn/20210707225212729.png?" alt="在这里插入图片描述" style="zoom: 25%;" />

#### bean 作用域

- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。

- prototype : 每次请求都会创建一个新的 bean 实例。

- request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。

- session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。

- global-session： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。	

#### bean生命周期流程图

[一文读懂 Spring Bean 的生命周期_spring bean的生命周期-CSDN博客](https://blog.csdn.net/riemann_/article/details/118500805)

<img src="https://img-blog.csdnimg.cn/20210710134349143.png" alt="在这里插入图片描述"  />

#### Spring循环依赖及解决办法

参考内容：[Spring 循环依赖那些事儿（含Spring详细流程图） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/635659531)

- 定义：循环依赖发生在两个或多个Bean直接或间接地相互依赖，创建了一个无法由Spring解决的循环。

- 出现场景：

  当Spring上下文在加载所有的bean时，他会尝试按照他们他们关联关系的顺序进行创建。比如，如果不存在循环依赖时，例如：
   Bean A → Bean B → Bean C
   Spring会先创建Bean C，再创建Bean B（并将Bean C注入到Bean B中），最后再创建Bean A(并将Bean B注入到Bean A中)。
   但是，如果我们存在循环依赖，Spring上下文不知道应该先创建哪个Bean,因为它们依赖于彼此。在这种情况下，Spring会在加载上下文时，抛出一个BeanCurrentlyInCreationException。

  当我们使用构造方法进行注入时，也会遇到这种情况。如果您使用其它类型的注入，你应该不会遇到这个问题。因为它是在需要时才会被注入，而不是上下文加载被要求注入。

- Spring为了解决单例的循环依赖问题，使用了三级缓存。

  步骤

  1.Spring首先从一级缓存singletonObjects中获取。

  2.如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。

  3.如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取.

  4.如果从三级缓存中获取到就从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。

- 编码出现循环依赖可使@Lazy注解

#### Spring之AOP编程

如果加入容器的目标对象有实现接口,用JDK代理
如果目标对象没有实现接口,用Cglib代理

#### Spring之依赖注入（DI）

- 定义：

  软件模块定义它们所需要的依赖（如服务、配置数据等）， 一个外部系统（通常是框架或容器）在运行时动态提供这些依赖。

- 方式工作
  1. 通过构造器注入：Spring通过类的构造器参数注入依赖。
  2. 通过Setter方法注入：依赖可以通过Bean的Setter方法被注入。
  3. 基于注解的注入：使用注解（如@Autowired）直接在属性、构造器或方法上注入依赖。
  4. XML文件注入：在Spring的XML配置文件中定义Bean及其依赖。

这种机制减少了代码间的耦合度，使得组件更易于测试和维护。

#### Spring之IoC（控制反转）？

IoC（控制反转）是Spring框架的核心概念，它指的是：

1、控制权转移：将对象创建和管理的控制权从程序代码转移给框架。

2、依赖注入：IoC的一种实现方式，Spring框架通过依赖注入将组件彼此连接起来。

3、减少耦合：IoC使得代码之间的耦合度降低，提高了代码的可测试性和可维护性。

#### Spring框架中的设计模式有哪些？

Spring框架使用了多种设计模式，包括但不限于：

1、单例模式 在Spring默认的作用域中，每个Bean都是单例的。

2、工厂模式：BeanFactory和ApplicationContext是工厂模式的实现。

3、代理模式：Spring AOP和Spring Security底层使用了代理模式。

4、模板方法模式：如JdbcTemplate、HibernateTemplate等，提供了一种模板方法的实现。

5、观察者模式：Spring事件机制的实现。 

6、适配器模式：Spring MVC中的Controller适配器。

7、装饰器模式：在资源视图等方面使用。

这些设计模式使得Spring框架非常灵活且易于扩展。

#### 事务特性

特性：ACID，即原子性(atomicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)。



#### 事务传播特性

1. REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
2. SUPPORTS： 如果当前存在事务，则加入该事务；如果没有，则以非事务方式执行。
3. MANDATORY： 如果当前存在事务，则加入该事务；如果没有，则抛出异常。
4. REQUIRES_NEW： 总是创建一个新的事务，如果当前存在事务，则挂起当前事务。
5. NOT_SUPPORTED： 总是非事务地执行，如果当前存在事务，则挂起当前事务。
6. NEVER： 总是非事务地执行，如果当前存在事务，则抛出异常。
7. NESTED： 如果当前存在事务，则在嵌套事务内执行；如果没有，则行为同REQUIRED。

#### 事务隔离特性

1. 读未提交
2. 读已提交
3. 可重复读
4. 串行化

#### Spring MVC和Spring WebFlux之间区别

Spring MVC和Spring WebFlux都是Spring框架用于构建Web应用的模块，主要区别在于：
1. 编程模型：Spring MVC是基于Servlet API和同步阻塞架构，而WebFlux是基于Reactive编程模型。
2. IO处理：Spring MVC使用传统的阻塞IO，WebFlux支持非阻塞IO。
3. 性能：在高负载和低延迟要求的场景下，WebFlux可以提供更高的性能。
4. 适用场景：Spring MVC适合传统的Web应用开发，WebFlux适合处理长时间运行的异步任务和高并发的场景。

#### Spring中如何使用AOP实现日志记录

1. 定义切面（Aspect）： 创建一个类作为切面，用于实现日志记录的逻辑。
2. 定义通知（Advice）： 在切面类中定义方法，使用@Before、@After、@Around等注解标注，以在目标方法前后或环绕执行日志记录。
3. 定义切点（Pointcut）： 使用表达式定义哪些方法需要被日志记录。
4. 配置AOP： 在Spring配置中启用AOP（如使用@EnableAspectJAutoProxy注解）。
5. 应用切面： 将切面应用到需要记录日志的业务逻辑上。

#### Spring中BeanFactory和ApplicationContext区别

BeanFactory和ApplicationContext是Spring容器的两种形式，它们的主要区别包括：

1. 功能范围： ApplicationContext比BeanFactory提供更多的功能，如事件传播、AOP支持等。
2. Bean的加载时机： BeanFactory是懒加载，即在请求时才创建Bean；ApplicationContext则在启动时就加载所有的Bean。
3. 国际化支持： ApplicationContext提供了国际化的支持，而BeanFactory没有。
4. 事件发布： ApplicationContext可以发布事件，BeanFactory则不支持。
5. 资源加载： ApplicationContext提供了更灵活的资源加载方式。

#### Spring中如何处理异常

1. @ControllerAdvice和@ExceptionHandler： 提供全局异常处理机制。
2. ResponseEntityExceptionHandler： 提供了处理常见Spring MVC异常的方法。
3. 自定义异常类： 创建自定义的异常类来处理特定的业务逻辑异常。
4. BindingResult： 在表单验证中使用，来处理验证错误。
5. @ResponseStatus： 可以在异常类上使用此注解定义异常对应的HTTP状态码。



# SpringBoot

#### 自动装配定义

Spring Boot的自动装配实际上是从`META-INF/spring.factories`文件中获取到对应的需要进行自动装配的类，并生成相应的Bean对象，然后将它们交给Spring容器进行管理



#### 自动装配原理

参照：[Spring Boot自动装配原理(易懂)](https://blog.csdn.net/qq_41805567/article/details/129111183)

Spring Boot的自动配置是一种机制，旨在根据项目中添加的依赖自动配置Spring应用。其工作原理如下：

1. @EnableAutoConfiguration注解： 这是Spring Boot自动配置的核心。它告诉Spring Boot根据添加到classpath中的jar依赖自动配置项目。

2. 条件注解： 如@ConditionalOnClass、@ConditionalOnBean，Spring Boot会检查条件是否匹配，只有匹配的情况下才会执行相应的自动配置。

3. 配置类： Spring Boot利用一系列自动配置类（通常以AutoConfiguration结尾），这些类封装了对应功能的默认配置。

4. application.properties或application.yml： 开发者可以在这些文件中覆盖自动配置的默认属性值。
    自动配置极大简化了Spring应用的初始搭建和配置过程，使得开发者能够快速启动和运行Spring应用。

  

  #### @SpringBootApplication注解结构

  ```
  @SpringBootConfiguration
  @EnableAutoConfiguration
  @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
       @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
  ```

  #### @EnableAutoConfiguration注解结构

  ```
  @AutoConfigurationPackage
  @Import(AutoConfigurationImportSelector.class)
  ```

  #### @AutoConfigurationPackage注解结构

  ```
  @Import(AutoConfigurationPackages.Registrar.class)
  ```

  #### 注解含义

  ```
  @SpringBootConfiguration : 标注在某个类上，表示这是一个Spring Boot的配置类；
  @ComponentScan : 配置扫描路径，用于加载使用注解格式定义的bean
  @EnableAutoConfiguration : 开启自动装配功能
  
  @AutoConfigurationPackage 指定了默认的包规则就是将主程序类所在包及所有子包下的组件扫描到Spring容器中;
  @Import(AutoConfigurationImportSelector.class) : 通过 @Import 注解导入 AutoConfigurationImportSelector类，然后通过该类的selectImports方法去读取MATE-INF/spring.factories文件中配置的组件的全类名，并按照一定的规则过滤掉不符合要求的组件的全类名，将剩余读取到的各个组件的全类名集合返回给IOC容器并将这些组件注册为bean
  ```

#### DevTools热部署



# SpringCloud

#### 微服务架构图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305130055240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70)

![微服务架构图](https://img-blog.csdnimg.cn/20190305130804158.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70)

#### 微服务架构演变

![img](https://img-blog.csdnimg.cn/20191222122236182.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70)

#### feign原理

- 定义:一个声明式的[HTTP客户端工具](https://so.csdn.net/so/search?q=HTTP客户端工具&spm=1001.2101.3001.7020)，用于简化服务之间的通信

- 原理:

1. 通过 @EnableFeignCleints 注解启动 Feign Starter 组件
2. Feign Starter 在项目启动过程中注册全局配置，扫描包下所有的 @FeignClient 接口类，并进行注册 IOC 容器
3. @FeignClient 接口类被注入时，通过 `FactoryBean#getObject` 返回动态代理类
4. 接口被调用时被动态代理类逻辑拦截，将 @FeignClient 请求信息通过编码器生成 Request
5. 交由 Ribbon 进行负载均衡，挑选出一个健康的 Server 实例
6. 继而通过 Client 携带 Request 调用远端服务返回请求响应
7. 通过解码器生成 Response 返回客户端，将信息流解析成为接口返回数据

- header传递：实现RequestInterceptor接口，通过@RequestHeader("headerName") 注解获取



#### Spring Cloud Gateway与Zuul的区别

1. 性能： Spring Cloud Gateway基于WebFlux和Netty，性能通常优于Zuul。
2. 异步非阻塞： Gateway使用异步非阻塞API，而Zuul使用的是阻塞API。
3. 长期支持： Spring Cloud Gateway是Spring官方推荐的网关方案，逐渐取代Zuul。
4. 路由功能： Gateway提供了更现代化的路由功能，例如Predicate和Filter的定制。

#### Spring Cloud Stream的工作原理及使用场景

1. 抽象消息中间件： Stream提供了一个高层次的抽象，用于与消息中间件（如Kafka、RabbitMQ）交互。
2. 发布-订阅模型： 支持发布-订阅和消费者组的模式，简化了消息的发送和接收过程。
3. 绑定器概念： Stream中的绑定器允许无缝切换不同的消息中间件。
4. 使用场景： 适用于需要处理高吞吐量、可靠性消息传递的微服务应用。

# Mybatis

#### 这个Dao接口的工作原理

Dao接口的工作原理是JDK动态代理，
Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，
代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。

#### Dao接口里的方法，参数不同时，方法能重载吗
Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

#### #{}和${}的区别

#{}是预编译处理， ${}是字符串替换。
Mybatis 在处理#{}时， 会将 sql 中的#{}替换为?号， 调用 PreparedStatement 的 set方法来赋值，使用#{}可以有效的防止 SQL 注入， 提高系统安全性。
Mybatis 在处理${}时， 就是把${}替换成变量的值。

#### 获取生成的主键

配置参数：useGeneratedKeys="true" keyProperty="userId"  

#### Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复

不同的Xml映射文件，如果配置了namespace，那么id可以重复；
如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。
原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。
有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。

#### 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系

Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。
在Xml映射文件中， 
<parameterMap> 标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。 
<resultMap> 标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。

每一个<select> 、 <insert> 、 <update> 、 <delete> 标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象



# 消息队列

#### 优点

异步处理， 流量削峰，应用解耦，日志处理，消息通讯

#### 缺点

增加系统复杂度， 系统可用性降低，产生数据一致性问题

#### 常见问题

消费重复问题：保证业务幂等性

消息顺序问题：保证生产者 - MQServer - 消费者是一对一对一的关系  

#### 消息队列基本概念

Broker： 简单来说就是消息队列服务器实体
Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列
Queue： 消息队列载体，每个消息都会被投入到一个或多个队列
Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来
Routing Key： 路由关键字，exchange根据这个关键字进行消息投递
VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的
queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。
Producer： 消息生产者，就是投递消息的程序
Consumer： 消息消费者，就是接受消息的程序
Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务
`由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。`

#### 死信队列

#### 延时队列

- redis

- RabbitMQ：

  利用特性：

  - A.消息的TTL(Time To Live)就是消息的存活时间，
  - B.DLX(Dead Letter Exchanges)是死信路由

  实现方式：**rabbitmq_delayed_message_exchange**插件

  实现原理：先发送一个消息到队列中，设置存活时间，超时后会转发到死信路由中，客户端消费死信路由中的消息，消息中包装好需要转发的队列名，再根据此队列名发送消息，这样间接中转的方式实现了延迟队列



# 分布式

#### CAP理论

#### BASE理论

#### 分布式事务

- 两阶段提交

- 三阶段提交

- TCC（Try, Confirm, Cancel）

  一阶段锁定和预备资源
  
  二阶段执行提交（confirm）或释放资源（cancel）。
  
  

# 任务框架

#### 任务调度

Quartz，Elastic，xxl-job

<img src="https://img-blog.csdnimg.cn/20200421134055562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pYW9taWFvMTk5NzEyMTU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" />

#### 定时任务常用几种方式

- JDK自带：使用java.util.TimerTask

  ```
  new Timer("timer - " + i).schedule(new TimerTask() {
      @Override
      public void run() {
      }
  }, 1000);
  ```

- JDK自带：ScheduledExecutorService

  默认实现为ScheduledThreadPoolExecutor 继承了ThreadPoolExecutor 的线程池特性，配合future特性，比Timer更强大。

- Quartz， JAVA作业调度框架，包含以下几个部分

  > Job：是一个接口，只有一个方法void execute(JobExecutionContextcontext)，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中；

  - > JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。

    > Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等；

    > Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。

    > Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。

    > Scheduler可以将Trigger绑定到某一JobDetail中，这样当Trigger触发时，对应的Job就被执行。一个Job可以对应多个Trigger，但一个Trigger只能对应一个Job。可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler#

    > getContext()获取对应的SchedulerContext实例；

    > ThreadPool：Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。

- Spring3.0以后自带的task。可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。

  `@Scheduled(cron="0/5 * *  * * ? ")   //每5秒执行一次 `



# 数据库

#### Mysql

##### INSERT or UPDATE执行流程

![318a8261d1205ffd09f9645359e57236](E:\Cache\wechat\WeChat Files\RS_1162501871\FileStorage\Temp\318a8261d1205ffd09f9645359e57236.jpg)



##### 索引结构与大小

- 索引的底层实现原理和优化：B+树， 经过优化的 B+树
  主要是在所有的叶子结点中增加了指向下一个叶子节点的指针， 因此 InnoDB 建议为大部分表使用默认自增的主键作为主索引。

- 最多联合索引列数：16

- 索引大小：

  联合索引idx_a的长度最大值 3072 bytes，**为什么3072，原因如下：**  
  InnoDB一个page的默认大小是16k。由于是Btree组织，要求叶子节点上一个page至少要包含两条记录（否则就退化链表了）。所以一个记录最多不能超过8k。

  又由于InnoDB的聚簇索引结构，一个二级索引要包含主键索引，因此每个单个索引不能超过4k （极端情况，primay-key和某个二级索引都达到这个限制）。

  由于需要预留和辅助空间，扣掉后不能超过3500，取个“整数”就是 (1024bytes*3=3072bytes)

##### MySQL 中有哪几种锁？

1、表级锁： 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。
2、行级锁： 开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。
3、页面锁： 开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。

自定义排序

主从同步原理

分库分表（水平拆分和垂直拆分）

Mysql 执行顺序

##### MyISAM和InnoDB引擎的区别

InnoDB支持事务, MyISAM不支持.
InnoDB支持行级锁, MyISAM支持表级锁.
InnoDB支持多版本并发控制(MVVC), MyISAM不支持.
InnoDB支持外键, MyISAM不支持.
MyISAM支持全文索引, InnoDB部分版本不支持(但可以使用Sphinx插件)

##### 事务隔离级别

<img src="E:\Cache\wechat\WeChat Files\RS_1162501871\FileStorage\Temp\1704096686145.png" alt="1704096686145" style="zoom: 80%;" />

##### 唯一索引比普通索引快吗, 为什么

唯一索引不一定比普通索引快, 还可能慢.
1. 查询时, 在未使用 limit 1 的情况下, 在匹配到一条数据后, 唯一索引即返回, 普通索引会继续匹配下一条数据, 发现不匹配后返回. 如此看来唯一索引少了一次匹配, 但实际上这个消耗微乎其微.
2. 更新时, 这个情况就比较复杂了. 普通索引将记录放到 change buffer 中语句就执行完毕了. 而对唯一索引而言, 它必须要校验唯一性, 因此, 必须将数据页读入内存确定没有冲突, 然后才能继续操作. 对于写多读少的情况, 普通索引利用 change buffer 有效减少了对磁盘的访问次数, 因此普通索引性能要高于唯一索引

##### MySQL优化-索引

尽量使用主键查询: 聚簇索引上存储了全部数据, 相比普通索引查询, 减少了回表的消耗.
MySQL5.6之后引入了索引下推优化, 通过适当的使用联合索引, 减少回表判断的消耗.
若频繁查询某一列数据, 可以考虑利用覆盖索引避免回表.
联合索引将高频字段放在最左边.

##### MySQL优化方法

1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL， 例如’ 省份’、’ 性别’ 最好适用 ENUM
2、使用连接(JOIN)来代替子查询
3、适用联合(UNION)来代替手动创建的临时表
4、事务处理
5、锁定表、优化事务处理
6、适用外键， 优化锁定表
7、建立索引
8、优化查询语句

##### MySQL优化-锁

1、读写分离
2、分段加锁
3、减少锁持有的时间
4、多个线程尽量以相同的顺序去获取资源
不能将锁的粒度过于细化， 不然可能会出现线程的加锁和释放次数过多， 反而效率不如一次加一把大
锁。

##### 索引失效的10种场景

1. 不满足最左匹配原则：联合索引A, B, C, A必须要在查询条件中
2. 使用了select *
3. 索引列上有计算
4. 索引列用了函数
5. 字段类型不同
6. like左边包含%
7. 列对比
8. 使用or关键字
9. not in和not exists不走， in和 exists可以走索引
10. order by的坑， **联合索引中必须加 limit！！！**才能走索引

##### 数据库三大范式

第一范式: 属性不可再分.
第二范式: 在一范式的基础上, 要求数据库表中的每个实例或行必须可以被惟一地区分. 通常需要为表加上一个列, 以存储各个实例的惟一标识. 这个惟一属性列被称为主关键字或主键.
第三范式: 在二范式的基础上, 要求一个数据库表中不包含已在其它表中已包含的非主关键字信息.所以第三范式具有如下特征：1). 每一列只有一个值. 2). 每一行都能区分. 3). 每一个表都不包含其他表已经包含的非主关键字信息

##### 自定义排序实现方式

参考文章：https://blog.csdn.net/Ajekseg/article/details/126036613
实现方式：filed， locate， 数据库字段自定义sort，order by + when case条件判断 

##### 行转列sql应该怎么写



#### Redis

##### redis 特性：

原子性：通过 MULTI 和 EXEC 指令包起来  

单线程：Redis的setnx命令可以用于实现分布式锁。在分布式应用中，为了保证同一时刻只有一个线程执行关键代码，可以使用Redis的分布式锁功能来实现。可以与expire一起使用

支持两种数据持久化：

- RDB： 

  1. 只有一个文件 dump.rdb， 方便持久化 。

  2. 容灾性好 。

  3. 性能最大化， fork 子进程来完成写操作  

- AOF：

  1. 数据安全  
  2. 过 append 模式写文件， 即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题
  3. AOF 机制的 rewrite 模式。AOF 文件没被 rewrite之前（ 文件过大时会对命令进行合并重写）， 可以删除其中的某些命令（ 比如误操作的 flushall）)

##### 基本数据类型

Redis 支持五种数据类型： string（ 字符串），hash（ 哈希）， list（ 列表）， set（ 集合） 及zsetsorted set： 有序集合)。

##### redis 过期键删除策略

1、定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，
立即执行对键的删除操作。
2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是 否过期， 如果过期
的话， 就删除该键;如果没有过期， 就返回该键。
3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至 于要删除多少过期
键， 以及要检查多少个数据库， 则由算法决定。

##### redis回收策略

noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
allkeys-random: 回收随机的键使得新添加的数据有空间存放。
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

##### 使用过 Redis 做异步队列么，你是怎么用的？

`一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候， 要适当sleep 一会再重试。`

如果对方追问可不可以不用 sleep 呢？

`list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。`

能不能生产一次消费多次呢？ 

`使用 pub/sub 主题订阅者模式， 可以实现1:N的消息队列。`

如果对方追问pub/sub有什么缺点？

`在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ 等。`

如果对方追问 redis 如何实现延时队列？

`使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。`

##### 过期时间和永久有效分别怎么设置？

EXPIRE 和 PERSIST 命令。

##### 缓存击穿及解决方案

1、布隆过滤器

2、把不存在的数据也缓存起来 ，比如有请求总是访问 key = 23 的数据，但是这个 key = 23 的数据在系统中不存在，可以考虑在缓存中构建一个( key=23 value = null)的数据。  



# 大数据





# 前端

#### Vue 双向绑定原理

是采用数据劫持结合发布者-订阅者模式的方式，

通过Object.defineProperty()来劫持各个属性的setter，getter，

在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210108140237683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdWd1YW5nemhhbw==,size_16,color_FFFFFF,t_70)

#### compute 和 watch区别

computed：是一个计算属性，根据依赖的响应式数据动态计算新的值

watch： 是 Vue 实例中一个观察者，它可以[监听](https://so.csdn.net/so/search?q=监听&spm=1001.2101.3001.7020)某个特定的数据。比compute提供了更为细粒度的控制，可以在数据变化时执行异步或复杂的操作

#### 第一次页面加载会触发哪几个钩子

beforeCreate，created，beforeMount，mounted

#### created和mounted的区别

created：在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。

mounted：再模板渲染成html后调用，通常是初始化页面完成后，再对html的DOM节点进行一些需要的操作。

#### H5 盒子属性列举

#### vue获取数据在哪个周期函数

一般 created / beforeMount / mounted 皆可。

如果你要操作 DOM ，那肯定是 mounted 时候才能操作。

#### 请详细说下你对vue生命周期的理解？

总共分为8个阶段 ：创建前/后，载入前/后，更新前/后，销毁前/后。

- 创建前/后（beforeCreate / created）：

  在beforeCreated阶段，vue实例的挂载元素 $el和 数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。

- 载入前/后（beforeMount / mounted）：

  在beforeMount阶段，vue实例的 $el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message 还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。

- 更新前/后（beforeUpdate / updated）：

  当data变化时，会触发beforeUpdate和updated方法。

- 销毁前/后()：

  在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。

#### 跨域及带来的问题及解决方案

- 产生原因：

  跨域问题其实就是浏览器的同源策略所导致的。

  在域名 （或 ip 地址）相同，端口号相同下的请求资源，可以看做是**同域资源**

- 解决办法：

  - SpringBoot后端进行处理，  Controller 类上加入 @CrossOrigin 注解
  - 前端使用proxy代理



# DevOps





# K8s

模型组件

kube-scheduler是k8s的pod调度器

kube-controller-managerpod进行管理负责对pod进行重建

kubelet node节点上创建、删除容器并利用探针进行健康性检查，向apiserver汇报pod状态和资源利用率

kube-porxy 在node节点维护iptables转发和ipvs规则，保持容器间的正常网络通讯

etcd是Kubernetes提供默认的存储系统，保存所有集群数据

k8s标准协议



CSI container storage interface 存储接口组件
CRI container runtime interface 运行时接口组件
CNI container network interface 网络组件

基础概念

常用插件

常见问题



# Linux





# 性能调优

常用性能评价和测试指标

并发数(QPS)：每秒查询

吞吐量(TPS)：每秒数量

线程数(RT)：响应时间 

IO速度：

前端优化常用手段 

1. 减少请求数量
2. 使用cdn加速
3. 使用反向代理缓存



堆栈分析工具：JProfile， MemoryAnalyzerTools（MAT）

负载测试工具：JMeter

接口安全扫描：AppScan

微服务在实时流量：Grafana

堆栈跟踪工具：jstack

虚拟机统计信息监控工具：jstat

生成虚拟机的内存转储快照（heapdump文件）：jmap

 Java 诊断工具：Arthas（阿尔萨斯）

数据库性能测试：sysbench，LoadRunner



# 网络

#### OSI七层网络模型

![BrandImg](https://pic1.zhimg.com/v2-1dd6e1ed2f348db47ce0cde38d545ae9_r.webp?source=172ae18b&consumer=ZHI_MENG)

![img](https://pic3.zhimg.com/v2-1578921092d775e024345fa8a531a85e_b.webp?consumer=ZHI_MENG)

#### 网络数据传输过程

[一文看懂网络七层协议/OSI七层模型 (zhihu.com)](https://www.zhihu.com/tardis/zm/art/296670054?source_id=1005)

- 物理层：解决两个硬件之间怎么通信的问题，常见的物理媒介有光纤、电缆、中继器等
- 数据链路层：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输**数据帧**的数据链路。
- 网络层：通过路由选择算法，为报文（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了IP协议
- 传输层：监控数据传输服务的质量，保证报文的正确传输
- 会话层：它的作用就是建立和管理应用程序之间的通信。建立一个自动收发包，自动寻址的功能
- 表示层：数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。
- 应用层：其功能是直接向用户提供服务

#### Socket 与 Http协议区别

- TCP连接原理

  三次握手， 建立连接不传输数据， 建立连接双方中的任何一方主动断开连接之前 TCP 连接会一直保持下去。

- http协议：使用的是"请求-响应"方式，短连接。

- Socket连接：套接字, 例如Internet、Unix、X.25。是个接口，并非协议。创建连接时可以指定TCP 或者UDP协议， 属于长连接。应用于即时聊天，服务器推送等服务

  ![socket是什么？套接字是什么？](https://pic1.zhimg.com/70/v2-8302577e2963b8a605e72234f25d6082_1440w.image?source=172ae18b&biz_tag=Post)

#### 三次握手过程

[一文彻底搞懂 TCP三次握手、四次挥手过程及原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/108504297)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201107101446617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0cl9seWM=,size_16,color_FFFFFF,t_70#pic_center)

#### 大文件上传设计



# 微服务相关问题

#### 微服务定义

微服务架构样式是一种将单个应用程序开发为一**组小型服务的方法**，每个**小型服务**都**在自己的进程中运行**并与轻量级机制（通常是HTTP资源API）进行通信。这些服务**围绕业务功能构建，**并且可以 由全自动部署机制**独立部署**。有一个**集中管理的最低限度的**这些服务，可以用不同的编程语言和使用不同的数据存储技术。


#### 微服务架构特点

服务组件化、去中心化、基础设施自动化



#### 微服务架构能力与技术组件

- 服务网关：降低服务客户端与服务提供者之间的耦合度。Zuul(阻塞IO)、SpringCloudGateway(非阻塞IO)

  服务网关在完成客户端与服务器端报文格式转换的同时，它可能还具有身份验证、监控、缓存、请求管理、静态响应处理等功能。另一方面，也可以在网关层制定灵活的路由策略。针对一些特定的 API，我们需要设置白名单、路由规则等各类限制

- 服务配置：Spring Cloud Config、Zookeeper 、apollo、nacos

- 服务安全：

  在实现微服务安全访问上，我们通常使用 OAuth2 协议来实现对服务访问的授权机制，使用 JWT 技术来构建轻量级的认证体系。Spring 家族也提供了 Spring Security 和 Spring Cloud Security 框架来完整这些组件的构建。

- 服务监控与链路跟踪：监控服务调用的健康状态以及全链路的数据流转。Spring Cloud Sleuth 与 Zipkin 的集成方案。

- 服务通信：

  - 网络连接模式：TCP 协议（全称Transmit Control Protocol）的网络连接两种基本方式，Socket长连接、Http短连接。

  - IO模型：阻塞、非阻塞

  - 服务调用方式：同步的方式进行方法调用，而框架本身会基于 Future 等机制实现异步的远程处理。

- 服务治理：服务注册中心进行服务管理。Eureka， k8s Proxy, Nacos

- 服务路由：可以认为负载均衡是最常见的一种路由方案，常见的客户端/服务器端负载均衡技术都可以完成服务路由。Ribbon

- 服务容错与限流：服务访问出错问题，微服务架构中提供了服务隔离、服务熔断和服务回退等面向服务调用端的有效容错机制。Hystrix、Resilience4J、Sentinel

#### 微服务设计原则

- 垂直划分优先原则
- 持续演进原则
- 服务自治和接口隔离原则
- 自动化驱动原则
- 



#### 微服务拆分

- 拆分可以分为系统拆分、功能拆分和读写拆分。

- 指导思想：

  - 解耦和
  - 康为定律：一个组织的系统通常被设计成这个组织通信结构的副本。

  - 服务内聚：就是以领域驱动设计为原则，重新界定领域边界，对模块进行服务整合，对系统进行合并。

  - 去层次化：去除服务层次高低之分，按服务调用最优链路提供服务请求，降低深度，以此保证系统的稳定性能。

- 拆分步骤

  - 制定微服务拆分粒度决策表
  - 拆分前做好解耦
  - 拆分前注意事项
    - 定时任务
    - 本地存储
    - 本地缓存
    - 去触发器 和存储过程
    - 通过接口隔离



#### 微服务拆分原则

参考资料：[微服务架构与拆分方案、原则 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/648629746)

基于业务复杂度划分服务

- 基于数据驱动划分原则

  **第一步，需求分析**。通过领域专家（或者产品经理）确定目标，然后总结user story，确定核心的业务流程。

  通过工具呈现比较粗糙的界面，内部讨论。不断迭代此环节，直到满意为止。
  **第二步，抽象数据结构**。根据需求总结use case，协助分析需求，从中抽象数据结构。
  **第三步，划分服务**。分析数据结构，识别服务，服务应该满足高内聚、低耦合、单一职责等特征。
  **第四步，确定服务调用关系**。先分析出主要流程，根据请求需要调用的服务确定服务调用关系。如果存在问题，需要从第一步重新开始。
  **第五步，业务流程验证**。重新回到user story，以服务为粒度实现时序图，注意此阶段重点是要验证服务划分是否合适，要关注如下问题。
  • 一次更新操作如果要跨越更多服务，那么一致性的要求是什么。
  • 跨服务查询时，是否要做关联查询，一个服务内是否能解决问题。
  • 性能是否能满足要求。
  • 成本是否满足要求。
  **第六步，持续优化**。

- 基于领域驱动划分原则

  **第一步**，通过模型和领域专家建立统一语言。建立统一语言是为了更深入的理解需求，通用语言尽量以业务语言为主，而非技术语言。通用语言和代码一样，需要不断的重构。
  **第二步**，业务分析。确定核心的业务流程，然后逐步扩展到全部。最好通过工具呈现比较粗糙的界面，内部讨论。
  **第三步**，寻找聚合。显式地定义了领域模型的边界。事件风暴是一种基于领域驱动分析业务，划分服务的方法。

  事件风暴就是把所有的关键参与者都召集到一个很宽敞的屋子里来开会，并且使用便利贴来描述系统中发生的事情，如图2-5所示。

  • 用桔黄色的便利贴代表领域事件，在上面用一句话描述曾经发生过什么事情。

  • 用蓝色的便利贴代表命令。命令的发起者可能是人，是注入系统中的外部事件，或是定时器等。

  • 用黄色的便利贴代表聚合，聚合是一组相关领域对象的集合，高内聚，低耦合，聚合内保证数据一致性。

  

  ![img](https://pic2.zhimg.com/80/v2-64072bcd8b720a3c9103cfd5aa09b3bd_720w.webp)

  **第四步**，确定服务调用关系。先分析出主要流程，根据一次请求需要调用的服务确定服务调用关系。如果存在水平划分，则需要根据服务依赖原则确定关系。如果存在问题，则需要从第一步重新开始。

  **第五步**，业务流程验证。以服务为粒度实现时序图，注意此阶段重点是要验证服务划分是否合适，重点要关注的问题如下。

  • 一次更新操作如果要跨越更多服务，那么一致性的要求是什么。

  • 跨服务查询时，是否要做关联查询，一个服务内是否能解决问题。

  • 性能是否能满足要求。

  • 成本是否满足要求。

  **第六步**，持续优化。



# 架构之理论篇

#### 架构的目的

架构的主要目的是支持系统的生命周期。

良好的架构使系统易于理解，易于开发，易于维护和易于部署。

最终目标是最小化系统的寿命成本并最大化程序员的生产力。



#### 如何评价一个系统架构的好坏

一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。

如果该成本很低，并且在系统的整个生命周期内一直都能维持这样的低成本，那么这个系统的设计就是优良的。

好的软件架构支持如下几点

- 系统的用例与正常运行

- 系统的维护

- 系统的开发

- 系统的部署



#### 构建高质量软件架构前提

要想提高自己软件架构的质量，就需要先知道什么是优秀的软件架构。

而为了在系统构建过程中采用好的设计和架构以便减少构建成本，提高生产力，

又需要先了解系统架构的各种属性与成本和生产力的关系。



#### 编程三大范式

结构化编程（structured programming）

面向对象编程（object-oriented programming）

函数式编程（functional programming）



1) 过程式编程：过程式编程是一种按照预定步骤和顺序执行任务的编程范式。在过程式编程中，程序员需要明确指定每个步骤的执行顺序和依赖关系。相比之下，事件驱动编程更加灵活，可以根据外部事件动态地调整执行流程。
2) 面向对象编程（object-oriented programming）：面向对象编程是一种基于类和对象的编程范式。在面向对象编程中，程序员需要定义类和对象，并通过封装、继承和多态等特性来实现代码的重用和扩展。事件驱动编程也可以与面向对象编程相结合，将事件处理逻辑封装在对象中，并通过对象之间的交互来处理事件。
3) [函数式编程](https://zhida.zhihu.com/search?q=函数式编程&zhida_source=entity&is_preview=1)（functional programming）：函数式编程是一种基于函数的编程范式，强调将计算过程看作是一系列函数调用的组合。在函数式编程中，程序员需要定义一系列[纯函数](https://zhida.zhihu.com/search?q=纯函数&zhida_source=entity&is_preview=1)，这些函数没有副作用，并且只依赖于输入参数。相比之下，事件驱动编程更加注重于处理异步事件和回调函数，而不是纯粹的函数计算。
4) 响应式编程：响应式编程是一种处理异步数据流的编程范式。在响应式编程中，程序员需要定义一系列数据流和操作符，并通过组合这些操作符来处理异步数据。与事件驱动编程相似，响应式编程也强调异步处理和回调机制，但更加注重于数据流的组合和转换。
5) 事件编程：



#### 六大架构设计原则（SOLID）

- 单一职责原则（Single Responsibility Principle）：任何一个软件模块都应该只对某一类行为者负责。软件模块”指的就是一组紧密相关的函数和数据结构。

- 开闭原则（Open Closed Principle）：如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。

- 里氏替换原则（Liskov Substitution Principle）：项原则的意思是如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换。

  <!-- 迪米特法则（Law of Demeter），又叫“最少知道法则”, 待论证 -->

- 接口隔离原则（Interface Segregation Principle）：主要告诫软件设计师应该在设计中避免不必要的依赖。

- 依赖倒置原则（Dependence Inversion Principle）：设计原则指出高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。

- <!-- CCP共同闭包原则 -->

  

#### 组件构建原则

##### 组件定义

是整个软件系统在部署过程中可以独立完成部署的最小实体

##### 组件构建原则-组件聚合

- 组件聚合三大原则

  - REP: The Reuse/Release Equivalence Principle，复用/发布等同原则。软件复用的最小粒度应等同于其发布的最小粒度。

  - CCP: The Common Closure Principle，共同闭包原则。

    主要作用就是提示我们要将所有可能会被一起修改的类集中在一处。

    我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，

    而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。

    以有效地降低因软件发布、验证及部署所带来的工作压力。

  - CRP: The Common Reuse Principle，共同复用原则。原则建议我们将经常共同复用的类和模块放在同一个组件中

- 聚合张力图

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb11a35f395b42e9a6b76cb76f03c545~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

##### 组件构建原则-组件耦合

- 无依赖环原则（ADP）

  定义：组件依赖关系图中不应该出现环。

  解决“每周构建”问题，我们的解决办法是将研发项目划分为一些可单独发布的组件，这些组件可以交由单人或者某一组程序员来独立完成。当有人或团队完成某个组件的某个版本时，他们就会通过发布机制通知其他程序员，并给该组件打一个版本号，放入一个共享目录。这样一来，每个人都可以依赖于这些组件公开发布的版本来进行开发，而组件开发者则可以继续去修改自己的私有版本。

  关键词：自上而下的设计、消除循环依赖、打破循环依赖（使用DIP依赖倒置原则）

  产生的问题：组件依赖关系会产生相应的抖动和扩张

- 稳定依赖原则（SDP,  Stable Dependencies Principle）

  依赖关系必须要指向更稳定方向， 遵守共同闭包原则（CCP）。稳定指的是“很难移动”。所以稳定性应该与变更所需的工作量有关。

  通过该原则，确保设计中容易变更的模块不会被那些难于修改的组件所依赖。

  量化稳定性方式：`I=Fan-out/(Fan-in+Fan-out)`

  - Fan-in：入向依赖，这个指标指代了组件外部类依赖于组件内部类的数量。
  - Fan-out：出向依赖，这个指标指代了组件内部类依赖于组件外部类的数量。
  - I：不稳定性，该指标的范围是[0,1]，I=0 意味着组件是最稳定的，I=1 意味着组件是最不稳定的。

- 稳定抽象原则（SAP， Stable Abstractions Principle）

  一个组件的抽象化程度应该与其稳定性保持一致。高阶策略放在抽象类中。

  - 为组件的稳定性与它的抽象化程度建立了一种关联。

    一方面，该原则要求稳定的组件同时应该是抽象的，这样它的稳定性就不会影响到扩展性。

    另一方面，该原则也要求一个不稳定的组件应该包含具体的实现代码，这样它的稳定性就可以通过具体的代码被轻易修改。

  - 如果一个组件想要成为稳定组件，那么它就应该由接口和抽象类组成，以便将来做扩展。

    如此，这些既稳定又便于扩展的组件可以被组合成既灵活又不会受到过度限制的架构。

  - 量化抽象程度方式：组件中抽象类与接口所占的比例，`A=Na/Nc`
    - Nc：组件中类的数量。
    - Na：组件中抽象类和接口的数量。
    - A：抽象程度。

![img](https://pic2.zhimg.com/v2-70bb5d47d52d69895e5e584bf1dc45e1_r.jpg)

##### 组件拆分

按层次拆分、按变更原因拆分

按变更原因拆分：就是业务用例，按变更原因进行组件拆分的例子是：订单组件、聊天组件。

按层次拆分：业务实体、用例、接口适配器、框架与驱动程序。

- 业务实体：关键业务数据和业务逻辑的集合，与界面无关、与存储无关、与框架无关，只有业务逻辑。
- 用例：特定场景下的业务逻辑，可以理解为 输入 + 业务实体 + 输出 = 用例。
- 接口适配器：包含整个整个MVC，以及对存储、设备、界面等的接口声明和使用。

一条策略距离系统的输入、输出越远，它的层次越高，所以业务实体是最高的层，框架与驱动程序是最低的层。

##### 组件依赖处理-整洁架构

- 独立于框架：这些系统的架构并不依赖某个功能丰富的框架之中的某个函数。框架可以被当成工具来使用，但不需要让系统来适应框架。

- 可被测试：这些系统的业务逻辑可以脱离 UI、数据库、Web 服务以及其他的外部元素来进行测试。

- 独立于 UI：这些系统的 UI 变更起来很容易，不需要修改其他的系统部分。例如，我们可以在不修改业务逻辑的前提下将一个系统的 UI 由 Web 界面替换成命令行界面。

- 独立于数据库：我们可以轻易将这些系统使用的 Oracle 、SQL Server 替换成 Mongo、BigTable、CouchDB 之类的数据库。因为业务逻辑与数据库之间已经完成了解耦。

- 独立于任何外部机构：这些系统的业务逻辑并不需要知道任何其他外部接口的存在。

  

![image-20240103141537263](C:\Users\micang\AppData\Roaming\Typora\typora-user-images\image-20240103141537263.png)

- 依赖关系规则

  源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。

##### **组件边界处理**

一个完整的组件边界包括哪些内容？首先跨越组件边界进行通信的两个类都要抽象为接口，另外需要声明专用的输入数据模型、声明专用的返回数据模型，想一想每次进行通信时都要进行的数据模型转换，就能理解维护一个组件边界的成本有多高。

除非必要，我们应该尽量使用不完全边界来降低维护组件边界的成本。不完全边界有三种方式：

- 省掉最后一步：声明好接口，做好分割后，仍然放在一个组件中，等到时机成熟时再拆出来独立编译部署。
- 单向边界：正常的边际至少有两个接口，分别抽象调用方和被调用方。这里只定义一个接口，高层次组件用接口调用低层次组件，而低层次组件直接引用高层次组件的类。
- 门户模式：控制权的间接转移不用接口和实现去做，而是用门户类去做，用这种方式连接口都不用声明了。

除了完全边界和不完全边界的区分，边界的解耦方式也可以分为3个层次：

- 源码层次：做了接口、类依赖上的解耦，但是放在同一个组件中，通常放在不同的路径下。和不完全边界的省略最后一步一样。
- 部署层次：拆分为可以独立部署的不同组件，比如 iOS 的静态库、动态库，真正运行时处于同一台物理机器上，组件之间通常通过函数调用通讯。
- 服务层次：运行在不同的机器上，通过 url 、网络数据包等方式进行通讯。

从上到下，（开发、部署）成本依次升高，如果低层次的解耦已经满足需要，不要进行高层次的解耦。

#### 领域驱动模型（DDD）



#### 架构风格

(参考文章连接：[后端 - 架构师蓝图: 理解软件风格与模式](https://segmentfault.com/a/1190000044640828))

##### 分层(Layered)

基于组件(Component-Based)

面向服务(Service-Oriented)

分布式系统(Distributed System)

领域驱动(Domain-Driven)

##### 事件驱动(Event-Driven)：

基本要素： 事件源 **->** 事件循环 **->** 事件监听，事件处理

风格介绍： [事件驱动-事件驱动应用于软件开发](https://zhuanlan.zhihu.com/p/683146381)

风格缺点： [事件驱动架构模式如何影响应用程序的性能](https://cloud.tencent.com/developer/techpedia/1923/13765)



关注点分离(Separation of Concern)

解释器(Interpreter)

并发(Concurrency)

以数据为中心(Data-Centric)



#### 架构模式

- 三层(tier)
- 微内核
- MVC
- MVVM



# 架构之技术篇

#### Mysql分库分表方案

Sharding-Sphere：[分库分表利器之Sharding Sphere（深度好文，看过的人都说好） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/425151447)

#### Mysql主从同步方案

主从同步原理：[mysql 主从同步原理 - 简书 (jianshu.com)](https://www.jianshu.com/p/65f31cbaedd6)

高可用方案：[五大常见的MySQL高可用方案 - 简书 (jianshu.com)](https://www.jianshu.com/p/056c2a0232a2)

#### Mysql多数据源配置：

使用框架：dynamic-datasource：[https://www.kancloud.cn/tracy5546/dynamic-datasource/2264611](https://www.kancloud.cn/tracy5546/dynamic-datasource/2264611?spm=a2c6h.13046898.publish-article.3.46636ffacBIaxI)

动态切换数据源：DynamicDataSourceContextHolder.push("master");

#### 分布式锁

实现方案：redis 或 [ZooKeeper](https://zookeeper.apache.org/)

#### 订阅与发布模式

#### OAuth2认证设计

#### 接口幂等设计

- 幂等定义：就是任意多次执行所产生的影响均与一次执行的影响相同
- 幂等使用场景：
  - 前端重复提交
  - 接口超时重试
  - 消息重复消费
- 解决方案：
  - Token实现机制， 全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成。
  - 基于mysql实现，实现方式是利用mysql唯一索引
  - 基于redis setNX， 设置成功时返回 1，设置失败时返回 0。

