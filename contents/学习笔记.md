# java

### 多线程

#### 面试题

1. 100万条数据导入到一个excel里应该怎么做？



#### 1. CompletableFuture手动事务提交

```java
@Service
public class MyService{
    @Autowired
    DataSourceTransactionManager transactionManager;
    
    public ResultMap lockStockWhenNewOrder(List<StockChangeByOrderDto> goodsModels) {
        //2.获取事务定义
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        //3.设置事务隔离级别，开启新事务
       def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        //4.获得事务状态，相当于开启事物
        TransactionStatus transactionStatus = transactionManager.getTransaction(def);
        try{
            //insert or update ...
            transactionManager.commit(transactionStatus);
        } catch (InterruptedException e) {
            transactionManager.rollback(transactionStatus);
        }
    }
}
```

#### 2. 线程池设置大小公式

`线程数 = 可用核心数 * 目标 CPU 利用率 * (1 + (等待时间 / 服务时间))`
`目标 CPU 利用率`：是您希望应用程序使用的 CPU 时间百分比(**CPU消耗/内核的CPU消耗的比率在65%~70%/30%~35%左右**)
`等待时间`：是线程等待 I/O 操作完成所花费的时间(**top 命令中cpus `wa<iowait>`参数**)
`服务时间`：是线程执行计算所花费的时间

#### 3. 响应比

1. 响应比 = (等待时间 + 要求服务时间) / 要求服务时间

#### 4. 防止内存泄漏的策略包括：

- 确保对象仅在需要时才处于范围内；
- 谨慎使用静态字段；
- 避免无限增长的静态集合；
- 在不再需要时，始终取消注册侦听器和回调；
- 限制缓存的大小；
- 在不再需要对象时，从集合中删除它们；
- 谨慎使用内部类实例；
- 使用后始终关闭资源（例如文件，流，连接）；
- 分析应用程序的内存使用情况；
- 单元和集成测试以检查内存泄漏。

#### 5. AQS & CAS 原理

#### 6. CAS有哪些应用类





# 设计模式

建造者

单例

代理(动态代理或静态代理)

责任链模式

策略模式

# netty



# JVM调优

#### jvm参数设置经验

1.Xmx 与 Xms设置大小一致
2.设置GC垃圾回收器标准：cpu >= 2 & mem > 1792MB ? G1(Java9 之前选ParallelGC) : SerialGC
3.容器部署，堆内存范围`-XX:MaxRAMPercentage=50%~75%`
4.一个容器cpu 2000m， 优于2个容器 cpu 1000m

#### 常用JVM参数

-XX:+UseContainerSupport 
-XX:InitialRAMPercentage=70.0 
-XX:MaxRAMPercentage=70.0 
-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps 
-Xloggc:/home/admin/nas/gc-${POD_IP}-$(date '+%s').log 
-XX:+HeapDumpOnOutOfMemoryError 
-XX:HeapDumpPath=/home/admin/nas/dump-${POD_IP}-$(date '+%s').hprof
-XX:MaxMetaspaceSize=256MB
-XX:ActiveProcessorCount=CPU个数（实际使用和指定数量不同会导致jvm效率低下）

#### 常用工具

`jps 查进程id`
`jmap -histo` 进程id 查看堆对象大小
`jmap -heap` 进程号 jvm内存配置
`jmap -dump:format=b,file=ssss.hprof 进程号`
`jstack 进程号 && visualVM检测` 查询死锁 `found one java-level deadlock`
`jstat -gc 进程号` 动态gc打印
`jinfo -flags 进程号` 查看jvm参数

#### 调优思路

- 现象：

  - 机器配置2核4G
  - JVM 内存：2G
  - 系统运行时间：7天
  - 发生fullGC 次数和耗时：500多次， 200多秒
  - 发生young gc次数和耗时：1W多次，500多秒

- JVM配置

  -Xms1536M
  -XmX1536M
  -Xmn512
  -XSS256K
  -XX:SurvivorRatio=6
  -XX:MetaspaceSize=256M
  -XX:MaxMetaspaceSize=256M
  -XX:+UseParNewGC
  -XX:+UseConcMarkSweepGC
  -XX:CMSInitiatingOccupancyFraction=75 `old75%触发FGC`
  -XX:+UseCMSInitiatingOccupancyOnly

- 年轻代增长速率：

  YGC触发频率和每次耗时： 每次YGC 50ms

  每次YGC 后有多少对象存活和进入老年代

  FGC触发频率和每次耗时：20分钟一次，每次fGC 400ms

- old区1G, 20分钟700M到老年代

  `可能原因：高峰情况下，对象太大，触发了担保机制直接进入老年代`

- 第一步优化： -Xmn1024  -XX:CMSInitiatingOccupancyFraction=92

  `调整后现象，fgc多于minor gc`

  `可能原因：触发担保机制 或者 metaspace空间不够导致扩容了`

- 通过jmap -histo 进程号查看堆内存对象情况， 

  byte[] 几百兆，然后找自己定义的类，对象个数10W+,

  通过方法执行过程中CPU飙升情况，通过`jstack`找到线程对应的代码方法。

  `找到了有个查询一次查5000条数据，查询对象太大了`。

- 第二步优化： 减少分页查询大小

  使用`jstat`查看发现不进行FGC问题

#### CPU飙升怎么办

`top` 查看资源占用情况
`top 进程号 + H` 查看当前进程下所有线程情况
使用visualVM找到线程对应的代码（十进制转十六进制）
`jstack 进程号 | grep -A 10 <十六进制值>` 找到代码行



# mybatis

# spring bean 创建

1. Bean创建生命周期
   Bean类文件 -- 
   调用无参构造函数 -- 
   生成对象 -- 
   依赖注入（给属性赋值（Autowired）） -- 	
   初始化前执行（Postconstruct） -- 
   初始化 -- 
   初始化后（AOP，生成代理对象） -- 
   	代理对象增加个被代理对象的私有属性，将原被代理对象的值赋值给该属性。
   	查找是否被切面，虽有切面方法缓存，执行直接查找缓存的方法	

# spring事务

#### 1. trans注解基于AOP创建代理对象

创建数据库链接

conn.autocommit = false

`执行业务方法逻辑`

conn.commit() 异常 则  conn.rollback()

#### 2. 事务传播

事务失效原因： trans注解必须调用代理的方法，传播属性才能生效

#### 3. 为什么要加@Configuration注解？

保证jdbcTemplate 和 代理中创建的链接使用同一个Datasource， 这样事务才能生效。

该注解使用代理，在bean注入时，查看bean缓存中是否已经有bean， 如果有则返回，由此保证同一个datasource

spring事务失效几种情况



# dubbo 

# eureka

# ribbon

负载均衡算法：

RoundRobinRule轮询（默认）：调用次数 % 服务个数取余， 同时调用使用cas算法获取最新次数
RandomRule随机
RetryRule轮询重试
WeightedResponseTimeRule响应速度决定权重
BestAvailableRule最优可用
AvailabilityFilteringRule可用性过滤规则
ZoneAvoidanceRule区域内可用性能最优

# feign 

#### 底层原理，如何组装http请求的

# hystrix

#### 是否自定义过熔断方式

# 分布式

#### 事务解决方案

1. Saga

   两种协调逻辑：编排 和 控制，
   两种恢复模式：向前恢复和向后恢复，
   适用场景：适用调用链路比较长

2. TCC（Try Confirm Cancel) 

   适用场景：资金数据，银行业务，金融业务，涉及到交易、支付、账务，**超卖**，都可以考虑。
   缺点：业务侵入比较大
   代表中间件：ali  Seata

3. 2PC

#### 分布式锁解决方案

1. 基于数据库实现分布式锁；
2. 基于缓存（Redis等）实现分布式锁
3. 基于Zookeeper实现分布式锁；

#### [如何设计接口幂等性](https://developer.aliyun.com/article/1588259)

1. **使用唯一标识**：为每个请求分配一个唯一的标识，例如请求 ID 或流水号。通过在请求中传递这个唯一标识，系统可以判断是否已经处理过该请求。
2. **设计幂等的操作**：确保操作本身是幂等的。例如，更新数据时可以采用"更新或插入"的策略，而不是直接修改已有记录。
3. **使用事务**：在涉及多个数据库操作的情况下，使用事务来确保整个操作的原子性和幂等性。
4. **利用缓存**：将请求的结果缓存起来，当接收到相同的请求时，直接返回缓存中的结果，避免重复执行操作。

#### 分布式ID方案 - 雪花算法

1. 数据库主键自增ID， 美团leaf方案
2. redis
3. 雪花算法：1s 1台 4096个ID 1bit标志位 + 41bit时间戳 + 10bit机器码 + 12bit序列号

# Redis

#### redis 数据结构（核心RedisObject）

String（3种数据结构存储方式）， List（2种）， Set（无序集合，2种），ZSet（有序集合，2种），Hash表（2种）

#### 过期删除策略

定期删除和惰性删除（定期删，查的时候删）

#### redis淘汰策略

配置内存（`maxmemory`不能超过内存大小）

- ##### no-envicition（默认）

- ##### **allkeys**-random

- ##### allkeys-lru

- allkeys-lfu

- ##### volatile-random

- ##### volatile-ttl

- ##### volatile-lru

- ##### volatile-lfu

```
config get maxmemory-policy    //获取当前内存淘汰策略
config set maxmemory-policy valatile-lru  //通过命令修改淘汰策略
```

#### 内存淘汰算法

- 随机
- TTL（过期时间）
- LRU（Least Recently Used，最近最少使用）
- LFU（Least Frequently Used，最不经常使用）

#### 四种集群部署模式

客户端分片
twemproxy： 只请求转发，无法在线扩容、缩容，运维不方便
Codis：proxy-请求读写转发，
	      dashboard-故障自动恢复，数据在线迁移，节点缩容扩容，自动化运维api
	      group-基于3.2.8版本开发的redis server，增加异步数据迁移
	      fe-管理多个集群UI界面

Redis Cluster：官方集群方案，支持数据节点迁移扩容，内置哨兵模式故障恢复功能

​	      通过smart-client进行路由转发
​	      节点数据迁移、扩容缩容时，告知客户端到正确节点
​	      缺点：迁移性能不高，大key的时候导致节点阻塞	      

#### 冷热备份（linux corntab定时任务， dump.rdb）

一小时，保留48小时
每天备份，保留一个月
本机备份，上传到云服务器

#### 性能调优

`server端`

1. 限制内存大小  2.使用lazy-free特性  3.使用slowlog优化耗时命令  4.检查数据持久化策略（通常用混合）  5.使用分布式架构 6.禁用THP特性

`client端`

1. 设置过期时间  2.禁止使用key *  3.严格控制数据结构大小  4.排序，交集 并集 放到客户端执行  5.删除大数据用异步删除方式unlink， 不阻塞主redis进程

#### 数据迁移

#### 分布式锁

`jedis.set(keys,args,"NX","PX",3000);`
该命令仅在密钥尚不存在时才设置密钥（NX选项），到期时间为3000毫秒（PX选项，EX选项单位为秒）

#### redis为什么那么快

redis client方案

Jedis

Redisson

集群执行lua脚本时键不在那个节点上怎么办

# rocketMQ

原理
集群部署

# 负载均衡 

Nginx（Tengine、Openresty）、zookeeper等负载均衡组件
git jenkins

# docker 

# k8s

# Vue2

#### 计算属性computed :

`支持缓存`，只有`依赖数据发生改变，才会重新进行计算`
`不支持异步`，当computed内有异步操作时无效，无法监听数据的变化
`computed 属性值会默认走缓存`，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值
如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

#### 侦听属性watch：

`支持缓存`，数据变，直接会触发相应的操作；
`watch支持异步`；
监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
当一个属性发生变化时，需要执行对应的操作；一对多；
监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，
	immediate：组件加载立即触发回调函数执行，
	deep: 深度监听，为了发现对象内部值的变化

#### Vue对象生命周期（4阶段，8钩子）

beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed

# ES 原理





cas AQS CurrentHashMap ArrayList

# 锁的升降级





# 网络

1. 网络三次握手

2. 网络模型

3. socket 与 rpc， http协议， dubbo协议， 区别

   - rpc: 进程之间通信方式，远程过程调用，是一种服务调用模式。包含 **传输协议** 和 **序列化协议**

     <img src="https://img2020.cnblogs.com/blog/980882/202006/980882-20200610111520262-1414556598.jpg" alt="img" style="zoom: 67%;" />

   - http协议 相较于 自定义tcp 报文协议：**增加的开销在于连接的建立与断开。**
   - 比如著名的 grpc，它底层使用的是 http2 协议；还有 dubbo 一类的自定义报文的 tcp 协议

# 微服务

#### 1. 微服务拆分原则